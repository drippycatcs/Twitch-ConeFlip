<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ConeFlip Admin Dashboard</title>
    <script src="/socket.io/socket.io.js"></script>
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* Light mode colors */
            --bg-gradient: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 50%, #f0fdf4 100%);
            --text-primary: #1f2937;
            --text-secondary: #4b5563;
            --text-tertiary: #6b7280;
            --text-link: #3b82f6;
            --text-code: #1f2937;
            --card-bg: rgba(255, 255, 255, 0.4);
            --card-border: rgba(255, 255, 255, 0.3);
            --input-bg: rgba(255, 255, 255, 0.6);
            --input-border: rgba(156, 163, 175, 0.3);
            --status-bg: rgba(255, 255, 255, 0.3);
            --status-border: rgba(0, 0, 0, 0.1);
            --pre-bg: rgba(255, 255, 255, 0.4);
            --scrollbar-track: rgba(255, 255, 255, 0.2);
            --scrollbar-thumb: #4b5563;
            --shadow-color: rgba(0, 0, 0, 0.1);
        }

        [data-theme="dark"] {
            /* Dark mode colors */
            --bg-gradient: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #0f1419 100%);
            --text-primary: #f8fafc;
            --text-secondary: #cbd5e1;
            --text-tertiary: #94a3b8;
            --text-link: #60a5fa;
            --text-code: #e2e8f0;
            --card-bg: rgba(30, 41, 59, 0.4);
            --card-border: rgba(51, 65, 85, 0.5);
            --input-bg: rgba(30, 41, 59, 0.6);
            --input-border: rgba(71, 85, 105, 0.5);
            --status-bg: rgba(30, 41, 59, 0.3);
            --status-border: rgba(51, 65, 85, 0.3);
            --pre-bg: rgba(15, 23, 42, 0.6);
            --scrollbar-track: rgba(30, 41, 59, 0.3);
            --scrollbar-thumb: #64748b;
            --shadow-color: rgba(0, 0, 0, 0.3);
        }

        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg-gradient);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
            transition: all 0.3s ease;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            padding: 25px 30px;
            border-radius: 16px;
            margin-bottom: 30px;
            border: 1px solid var(--card-border);
            box-shadow: 0 8px 32px var(--shadow-color);
            position: relative;
        }

        .header h1 {
            color: var(--text-primary);
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 8px;
            text-shadow: 0 2px 4px var(--shadow-color);
        }

        .header p {
            color: var(--text-secondary);
            font-size: 1.1rem;
        }

        .theme-toggle {
            background: var(--card-bg);
            border: 2px solid var(--card-border);
            border-radius: 50px;
            padding: 8px 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            color: var(--text-primary);
            font-size: 0.9rem;
            font-weight: 500;
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            gap: 8px;
            margin-right: 15px;
        }

        .theme-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px var(--shadow-color);
        }

        .auth-section {
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 50px;
            box-shadow: 0 20px 60px var(--shadow-color);
            text-align: center;
            max-width: 450px;
            margin: 150px auto;
            border: 1px solid var(--card-border);
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }

        .card {
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 25px;
            border: 1px solid var(--card-border);
            box-shadow: 0 8px 32px var(--shadow-color);
            transition: all 0.3s ease;
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 40px var(--shadow-color);
            border-color: var(--card-border);
        }

        .card-title {
            font-size: 1.4rem;
            font-weight: 600;
            margin-bottom: 20px;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 12px;
            border-bottom: 1px solid var(--input-border);
            padding-bottom: 15px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 14px 16px;
            border: 2px solid var(--input-border);
            border-radius: 10px;
            font-size: 1rem;
            background: var(--input-bg);
            backdrop-filter: blur(5px);
            color: var(--text-primary);
            transition: all 0.3s ease;
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #10b981;
            box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.1);
        }

        .btn {
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
            text-align: center;
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3);
            margin: 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
            box-shadow: 0 4px 15px rgba(107, 114, 128, 0.3);
        }

        .btn-secondary:hover {
            box-shadow: 0 6px 20px rgba(107, 114, 128, 0.4);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            box-shadow: 0 4px 15px rgba(239, 68, 68, 0.3);
        }

        .btn-danger:hover {
            box-shadow: 0 6px 20px rgba(239, 68, 68, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3);
        }

        .btn-success:hover {
            box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4);
        }

        .btn-full {
            width: 100%;
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 0.875rem;
        }

        .chip {
            display: inline-block;
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.875rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .chip-success {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
            border: 1px solid #10b981;
        }

        .chip-warning {
            background: rgba(245, 158, 11, 0.2);
            color: #f59e0b;
            border: 1px solid #f59e0b;
        }

        .chip-error {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
            border: 1px solid #ef4444;
        }

        .browser-info {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            background: var(--status-bg);
            border: 1px solid var(--status-border);
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        #browser-name {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 0.95rem;
        }

        .browser-type {
            background: rgba(59, 130, 246, 0.2);
            color: #3b82f6;
            border: 1px solid #3b82f6;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .refresh-indicator {
            margin-left: 8px;
            font-size: 0.875rem;
            animation: spin 1s linear infinite;
            opacity: 0.7;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .refresh-btn {
            background: rgba(59, 130, 246, 0.2);
            color: #3b82f6;
            border: 1px solid #3b82f6;
            padding: 6px 10px;
            margin-left: 8px;
            font-size: 0.875rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .refresh-btn:hover {
            background: rgba(59, 130, 246, 0.3);
            transform: scale(1.05);
        }

        .last-updated {
            color: var(--text-secondary);
            font-size: 0.875rem;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        }

        .setup-tab {
            background: rgba(239, 68, 68, 0.1) !important;
            color: #ef4444 !important;
            border: 1px solid rgba(239, 68, 68, 0.3) !important;
        }

        .setup-tab:hover {
            background: rgba(239, 68, 68, 0.2) !important;
        }

        .setup-tab.active {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%) !important;
            color: white !important;
        }

        .warning-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .warning-modal {
            background: var(--card-bg);
            border: 2px solid #ef4444;
            border-radius: 16px;
            padding: 30px;
            max-width: 500px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        .warning-icon {
            font-size: 4rem;
            color: #ef4444;
            margin-bottom: 20px;
        }

        .setup-field {
            margin-bottom: 20px;
        }

        .setup-field label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .setup-field input {
            width: 100%;
            padding: 12px;
            border: 2px solid var(--status-border);
            border-radius: 8px;
            background: var(--status-bg);
            color: var(--text-primary);
            font-size: 0.95rem;
        }

        .setup-field input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .setup-field.optional label::after {
            content: " (Optional)";
            color: var(--text-secondary);
            font-weight: normal;
            font-size: 0.875rem;
        }

        .token-field {
            position: relative;
        }

        .token-field input {
            width: 100%;
        }

        .hover-reveal-hint {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-secondary);
            font-size: 0.75rem;
            pointer-events: none;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .token-field:hover .hover-reveal-hint {
            opacity: 0;
        }

        .token-field:hover input[type="password"] {
            -webkit-text-security: none;
            text-security: none;
        }

        .token-field input[type="password"]:focus {
            -webkit-text-security: none;
            text-security: none;
        }

        .token-field input[type="password"]:focus + .hover-reveal-hint {
            opacity: 0;
        }

        .token-display {
            position: relative;
            font-family: 'Courier New', monospace;
            font-size: 0.875rem;
            background: var(--surface-2);
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid var(--border);
            margin-bottom: 10px;
            word-break: break-all;
            filter: blur(4px);
            transition: filter 0.2s;
        }

        .token-display:hover {
            filter: blur(0px);
        }

        .token-display::after {
            content: "Hover to reveal";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--text-secondary);
            font-size: 0.75rem;
            pointer-events: none;
            opacity: 0.8;
            transition: opacity 0.2s;
        }

        .token-display:hover::after {
            opacity: 0;
        }

        .token-display.no-blur {
            filter: none;
        }

        .token-display.no-blur::after {
            display: none;
        }

        .twitch-auth-section {
            background: rgba(147, 51, 234, 0.1);
            border: 2px solid rgba(147, 51, 234, 0.3);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }

        .twitch-auth-btn {
            background: linear-gradient(135deg, #9146ff 0%, #772ce8 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .twitch-auth-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(145, 70, 255, 0.3);
        }

        .connection-status {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .connection-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: var(--status-bg);
            border: 1px solid var(--status-border);
            border-radius: 6px;
            font-size: 0.9rem;
        }

        .connection-icon {
            font-size: 1.1rem;
        }

        .connection-success {
            background: rgba(34, 197, 94, 0.1);
            border-color: rgba(34, 197, 94, 0.3);
            color: #22c55e;
        }

        .connection-error {
            background: rgba(239, 68, 68, 0.1);
            border-color: rgba(239, 68, 68, 0.3);
            color: #ef4444;
        }

        .connection-checking {
            background: rgba(59, 130, 246, 0.1);
            border-color: rgba(59, 130, 246, 0.3);
            color: #3b82f6;
        }

        .token-display {
            background: var(--status-bg);
            border: 2px solid var(--status-border);
            border-radius: 10px;
            padding: 14px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.875rem;
            margin-bottom: 15px;
            word-break: break-all;
            color: var(--text-primary);
            backdrop-filter: blur(10px);
        }

        .copy-btn {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            font-size: 0.875rem;
            padding: 8px 16px;
            margin-left: 10px;
        }

        .tabs {
            display: flex;
            margin-bottom: 30px;
            background: var(--status-bg);
            border-radius: 16px;
            padding: 6px;
            border: 1px solid var(--status-border);
            overflow-x: auto;
            backdrop-filter: blur(10px);
        }

        .tab {
            flex: 1;
            padding: 12px 20px;
            border: none;
            background: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            color: var(--text-secondary);
            white-space: nowrap;
            min-width: 150px;
        }

        .tab.active {
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3);
        }

        .tab:hover:not(.active) {
            background: var(--card-bg);
            color: var(--text-primary);
        }

        .alert {
            padding: 14px 18px;
            border-radius: 10px;
            margin-bottom: 20px;
            border-left: 4px solid;
        }

        .alert-success {
            background: rgba(16, 185, 129, 0.1);
            color: #10b981;
            border-left-color: #10b981;
        }

        .alert-error {
            background: rgba(239, 68, 68, 0.1);
            color: #ef4444;
            border-left-color: #ef4444;
        }

        .alert-warning {
            background: rgba(245, 158, 11, 0.1);
            color: #f59e0b;
            border-left-color: #f59e0b;
        }

        .status-display {
            background: var(--status-bg);
            border: 1px solid var(--status-border);
            border-radius: 10px;
            padding: 16px;
            margin-top: 15px;
            backdrop-filter: blur(10px);
        }

        .status-display h4 {
            color: var(--text-primary);
            margin-bottom: 10px;
            font-size: 1rem;
        }

        .status-display pre {
            background: var(--pre-bg);
            color: var(--text-primary);
            padding: 12px;
            border-radius: 8px;
            overflow-x: auto;
            font-size: 0.875rem;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid var(--status-border);
        }

        .hidden {
            display: none;
        }

        .flex {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .flex-between {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .flex-wrap {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            max-width: 350px;
            border-radius: 12px;
            padding: 16px 20px;
            font-weight: 500;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }

        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        @media (max-width: 768px) {
            .grid-2 {
                grid-template-columns: 1fr;
            }
            
            .tabs {
                overflow-x: scroll;
            }
            
            .container {
                padding: 15px;
            }
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--scrollbar-track);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--scrollbar-thumb);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-tertiary);
        }

        /* Skin Management Styles */
        .skins-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        /* Trail Management Styles */
        .trails-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .trail-item {
            display: flex;
            flex-direction: column;
            padding: 15px;
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 10px;
            backdrop-filter: blur(10px);
            gap: 15px;
        }

        .trail-info {
            display: flex;
            align-items: center;
            gap: 15px;
            flex: 1;
        }

        .trail-preview {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            border: 1px solid var(--input-border);
            flex-shrink: 0;
        }

        .trail-details {
            flex: 1;
        }

        .trail-details h4 {
            margin: 0 0 8px 0;
            color: var(--text-primary);
            font-size: 1.1rem;
            font-weight: 600;
        }

        .trail-details p {
            margin: 3px 0;
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        .trail-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: space-between;
        }

        .trail-actions .btn {
            flex: 1;
            min-width: 70px;
            font-size: 0.85rem;
        }

        .skin-item {
            display: flex;
            flex-direction: column;
            padding: 15px;
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 10px;
            backdrop-filter: blur(10px);
            gap: 15px;
        }

        .skin-info {
            display: flex;
            align-items: center;
            gap: 15px;
            flex: 1;
        }

        .skin-preview {
            width: 60px;
            height: 60px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            border-radius: 8px;
            border: 1px solid var(--input-border);
            flex-shrink: 0;
        }

        .skin-details {
            flex: 1;
        }

        .skin-details h4 {
            margin: 0 0 8px 0;
            color: var(--text-primary);
            font-size: 1.1rem;
            font-weight: 600;
        }

        .skin-details p {
            margin: 3px 0;
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        .skin-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: space-between;
        }

        .skin-actions .btn {
            flex: 1;
            min-width: 70px;
            font-size: 0.85rem;
        }

        /* Responsive design for skin items */
        @media (max-width: 1024px) {
            .skins-grid {
                grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            }
        }

        @media (max-width: 768px) {
            .skins-grid {
                grid-template-columns: 1fr;
            }
            
            .skin-actions {
                justify-content: stretch;
            }
        }

        @media (max-width: 480px) {
            .skins-grid {
                grid-template-columns: 1fr;
                gap: 10px;
            }
            
            .skin-item {
                padding: 12px;
            }
            
            .skin-actions {
                flex-direction: column;
                gap: 6px;
            }
            
            .skin-actions .btn {
                flex: none;
                width: 100%;
                min-width: unset;
            }
        }

        .submission-item {
            padding: 15px;
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 10px;
            margin-bottom: 15px;
            backdrop-filter: blur(10px);
        }

        .submission-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .submission-info h4 {
            margin: 0;
            color: var(--text-primary);
        }

        .submission-info p {
            margin: 0;
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        .submission-preview {
            width: 80px;
            height: 80px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            border-radius: 8px;
            border: 1px solid var(--input-border);
            margin: 10px 0;
        }

        .submission-actions {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        /* Modal Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal.hidden {
            display: none !important;
        }

        .modal-content {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 0;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            backdrop-filter: blur(20px);
            border: 1px solid var(--card-border);
        }

        .modal-header {
            padding: 20px 25px;
            border-bottom: 1px solid var(--input-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h3 {
            margin: 0;
            color: var(--text-primary);
        }

        .modal-body {
            padding: 25px;
        }

        .btn-warning {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(245, 158, 11, 0.3);
        }

        .btn-warning:hover {
            box-shadow: 0 6px 20px rgba(245, 158, 11, 0.4);
        }

        /* OBS Configuration Note */
        .obs-note {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 20px;
            font-size: 0.85rem;
            color: var(--text-link);
        }

        .obs-note code {
            background: rgba(59, 130, 246, 0.15);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            color: var(--text-code);
        }

        /* Fix checkbox styling */
        input[type="checkbox"] {
            width: auto !important;
            height: auto !important;
            margin: 0 8px 0 0 !important;
            transform: scale(1.2);
            vertical-align: middle;
            cursor: pointer;
        }

        .form-group input[type="checkbox"] {
            display: inline-block;
            vertical-align: middle;
        }

        .form-group label {
            display: flex;
            align-items: center;
            cursor: pointer;
        }

        /* Ensure labels with checkboxes are properly aligned */
        label:has(input[type="checkbox"]),
        label:has(input[type="checkbox"]) + input[type="checkbox"] {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Clickable skin preview styles */
        .skin-preview, .submission-preview {
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            position: relative;
        }

        .skin-preview:hover, .submission-preview:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .skin-preview::after, .submission-preview::after {
            content: "üîç";
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .skin-preview:hover::after, .submission-preview:hover::after {
            opacity: 1;
        }

        /* Fullscreen modal specific styles */
        #fullscreenModal .modal-content {
            background: rgba(0, 0, 0, 0.9) !important;
            border: none !important;
        }

        #fullscreenModal .modal-header {
            background: rgba(0, 0, 0, 0.8) !important;
        }

        #fullscreenModal .modal-header button:hover {
            background: rgba(255, 255, 255, 0.2) !important;
        }

        /* Connected Browsers Styles */
        .connected-browsers {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 10px;
        }

        .session-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            background: var(--status-bg);
            border: 1px solid var(--status-border);
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }

        .session-item.multiple-warning {
            background: rgba(245, 158, 11, 0.1);
            border-color: rgba(245, 158, 11, 0.3);
        }

        .session-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
            flex: 1;
        }

        .session-browser {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 0.9rem;
        }

        .session-details {
            font-size: 0.8rem;
            color: var(--text-secondary);
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        }

        .session-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .warning-badge {
            background: rgba(245, 158, 11, 0.2);
            color: #f59e0b;
            padding: 2px 6px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: bold;
            border: 1px solid rgba(245, 158, 11, 0.4);
        }

        .disconnect-btn {
            background: #ef4444;
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s ease;
        }

        .disconnect-btn:hover {
            background: #dc2626;
            transform: scale(1.05);
        }

        .no-sessions {
            text-align: center;
            color: var(--text-secondary);
            padding: 20px;
            font-style: italic;
        }

        /* Nuclear Reset Modal Styles */
        .nuke-modal-content {
            max-width: 550px;
            text-align: center;
        }

        .nuke-modal-body {
            padding: 30px;
        }

        .nuke-step {
            display: none;
        }

        .nuke-step.active {
            display: block;
            animation: fadeInUp 0.3s ease;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .nuke-icon {
            font-size: 4rem;
            margin-bottom: 20px;
            animation: pulse 1s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .nuke-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #ef4444;
            margin-bottom: 15px;
        }

        .nuke-message {
            font-size: 1.1rem;
            color: var(--text-secondary);
            margin-bottom: 25px;
            line-height: 1.6;
        }

        .nuke-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .btn-nuke {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 50%, #b91c1c 100%);
            color: white;
            padding: 12px 30px;
            font-size: 1rem;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(239, 68, 68, 0.4);
        }

        .btn-nuke:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(239, 68, 68, 0.6);
        }

        .btn-chicken {
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            color: white;
            padding: 12px 30px;
            font-size: 1rem;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-chicken:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(34, 197, 94, 0.4);
        }

        /* Nuke Countdown Overlay */
        .nuke-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 9999;
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }

        .nuke-overlay.active {
            display: flex;
        }

        .nuke-countdown {
            font-size: 15rem;
            font-weight: 900;
            color: #ef4444;
            text-shadow: 0 0 50px rgba(239, 68, 68, 0.8),
                         0 0 100px rgba(239, 68, 68, 0.6),
                         0 0 150px rgba(239, 68, 68, 0.4);
            animation: countdownPulse 1s ease-in-out infinite;
            font-family: 'Impact', 'Arial Black', sans-serif;
        }

        @keyframes countdownPulse {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.15);
                opacity: 0.8;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .nuke-warning-text {
            font-size: 2rem;
            color: #fbbf24;
            text-transform: uppercase;
            letter-spacing: 8px;
            margin-bottom: 30px;
            animation: blink 0.5s ease-in-out infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .nuke-explosion {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: white;
            z-index: 10000;
            display: none;
            animation: explosion 2s ease-out forwards;
        }

        .nuke-explosion.active {
            display: block;
        }

        @keyframes explosion {
            0% {
                opacity: 1;
                background: white;
            }
            20% {
                background: #fef08a;
            }
            40% {
                background: #fb923c;
            }
            60% {
                background: #ef4444;
            }
            100% {
                opacity: 0;
                background: black;
            }
        }

        .nuke-complete {
            font-size: 3rem;
            color: #22c55e;
            text-align: center;
            animation: fadeInUp 0.5s ease;
        }

        .nuke-complete-icon {
            font-size: 5rem;
            margin-bottom: 20px;
        }

        .streamer-name-highlight {
            color: #a855f7;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- Login Section -->
        <div id="login-section" class="auth-section">
            <h2 style="margin-bottom: 20px; color: var(--text-primary);">Admin Dashboard</h2>
            <p style="margin-bottom: 30px; color: var(--text-secondary);">Login with Twitch to access the admin panel</p>

            <button class="btn btn-full" onclick="loginWithTwitch()" style="background: #9146ff; border-color: #9146ff;">
                <span style="margin-right: 8px;">üì∫</span>
                Login with Twitch
            </button>

            <div id="auth-error" class="alert alert-error hidden"></div>

            <div style="margin-top: 20px; font-size: 0.875rem; color: var(--text-secondary);">
                <p>Only the streamer and configured admins can access this panel.</p>
            </div>
        </div>

        <!-- Main Dashboard -->
        <div id="dashboard" class="hidden">
            <div class="container">
                <div class="header">
                    <div class="flex-between">
                        <div>
                            <h1>ConeFlip V2</h1>
                            <p>By <a href="https://x.com/drippycatcs" target="_blank" style="color: var(--text-link);">@drippycatcs</a></p>
                        </div>
                        <div class="flex">
                            <button class="theme-toggle" onclick="toggleTheme()">
                                <span id="theme-icon">üåô</span>
                                <span id="theme-text">Dark</span>
                            </button>
                            <button class="btn btn-secondary" onclick="logout()">Logout</button>
                        </div>
                    </div>
                </div>

                            <div class="tabs">
                <button class="tab active" onclick="switchTab(0)">Tokens</button>
                <button class="tab" onclick="switchTab(1)">Testing</button>
                <button class="tab" onclick="switchTab(2)">Skins</button>
                <button class="tab" onclick="switchTab(3)">Trails</button>
                <button class="tab" onclick="switchTab(4)">Leaderboard</button>
                <button class="tab" onclick="switchTab(5)">Announce</button>
                <button class="tab" onclick="switchTab(6)">Contest</button>
                <button class="tab" onclick="switchTab(7)">System</button>
                <button class="tab" onclick="switchTab(8)">Mods</button>
                <button class="tab setup-tab" onclick="switchTab(9)">Setup</button>
            </div>

                <!-- Token Management Tab -->
                <div id="tab-0" class="tab-content">
                    <div class="grid">
                        <div class="card">
                            <h3 class="card-title">Authentication Token</h3>
                            
                            <div class="form-group">
                                <label>Current Token:</label>
                                <div class="token-display" id="current-token">Loading...</div>
                                <button class="btn copy-btn btn-small" onclick="copyToken()">Copy</button>
                            </div>

                            <div class="form-group">
                                <label>Status:</label>
                                <span id="token-status" class="chip chip-success">Available</span>
                                <span id="status-refresh-indicator" class="refresh-indicator" style="display: none;">üîÑ</span>
                            </div>

                            <div class="form-group" id="browser-info-section">
                                <label>Connected Browsers:</label>
                                <div id="connected-browsers" class="connected-browsers">
                                    <div class="no-sessions">No active sessions</div>
                                </div>
                            </div>

                            <div class="form-group" id="twitch-connection-section">
                                <label>Twitch Connections:</label>
                                <div class="connection-status">
                                    <div id="streamer-connection" class="connection-item">
                                        <span class="connection-icon">üëë</span>
                                        <span id="streamer-status">Checking...</span>
                                    </div>
                                    <div id="bot-connection" class="connection-item">
                                        <span class="connection-icon">ü§ñ</span>
                                        <span id="bot-status">Checking...</span>
                                    </div>
                                </div>
                            </div>

                            <button class="btn btn-danger btn-full" onclick="revokeToken()">
                                Revoke & Regenerate Token
                            </button>
                        </div>

                        <div class="card">
                            <h3 class="card-title">OBS Browser Sources</h3>
                            
                            <div class="obs-note">
                                <strong>Configure OBS Browser Source:</strong><br>
                                Width: 1920, Height: 1080, Custom FPS: 60<br>
                                CSS: <code>body { background-color: rgba(0, 0, 0, 0); margin: 0; overflow: hidden; }</code><br>
                                Enable "Shutdown source when not visible" and "Refresh browser when scene becomes active"
                            </div>
                            
                            <div class="form-group">
                                <label>Game URL:</label>
                                <div class="token-display" id="obs-game-url">Loading...</div>
                                <button class="btn copy-btn btn-small" onclick="copyObsGameUrl()">Copy URL</button>
                            </div>

                            <div class="form-group">
                                <label>Leaderboard URL:</label>
                                <div class="token-display no-blur" id="obs-leaderboard-url">Loading...</div>
                                <button class="btn copy-btn btn-small" onclick="copyObsLeaderboardUrl()">Copy URL</button>
                            </div>

                            <div class="form-group">
                                <label>Unbox URL:</label>
                                <div class="token-display no-blur" id="obs-unbox-url">Loading...</div>
                                <button class="btn copy-btn btn-small" onclick="copyObsUnboxUrl()">Copy URL</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Game Testing Tab -->
                <div id="tab-1" class="tab-content hidden">
                    <div class="grid">
                        <div class="card">
                            <h3 class="card-title">Game Simulation</h3>
                            
                            <div class="form-group">
                                <label for="test-player-name">Player Name:</label>
                                <input type="text" id="test-player-name" value="test_user" />
                            </div>



                            <div class="form-group">
                                <label for="test-skin">Skin (optional):</label>
                                <input type="text" id="test-skin" placeholder="e.g., gold, rainbow" />
                            </div>

                            <div class="form-group">
                                <label for="duel-target">Duel Target (for duels):</label>
                                <input type="text" id="duel-target" value="test_opponent" placeholder="Opponent username" />
                            </div>

                            <div class="flex-wrap">
                                <button class="btn" onclick="simulateCone()">Simulate Cone</button>
                                <button class="btn btn-secondary" onclick="simulateDuel()">Simulate Duel</button>
                            </div>

                            <div class="status-display">
                                <h4>Game Results:</h4>
                                <pre id="game-results">No tests run yet</pre>
                            </div>
                        </div>

                        <div class="card">
                            <h3 class="card-title">Bulk Testing</h3>
                            
                            <div class="form-group">
                                <label for="bulk-count">Number of Tests:</label>
                                <input type="number" id="bulk-count" value="10" min="1" max="100" />
                            </div>

                            <div class="flex-wrap">
                                <button class="btn" onclick="bulkConeFlips()">Bulk Cones</button>
                                <button class="btn btn-secondary" onclick="stressTest()">Stress Test</button>
                            </div>

                            <div class="status-display">
                                <h4>Bulk Test Results:</h4>
                                <pre id="bulk-results">No bulk tests run</pre>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Skins Tab -->
                <div id="tab-2" class="tab-content hidden">
                    <!-- Top 3 cards in a row -->
                    <div class="grid">
                        <div class="card">
                            <h3 class="card-title">Skin Testing</h3>
                            
                            <div class="form-group">
                                <label for="skin-username">Username:</label>
                                <input type="text" id="skin-username" value="test_user" />
                            </div>

                            <div class="form-group">
                                <label for="unbox-count">Unbox Count:</label>
                                <input type="number" id="unbox-count" value="1" min="1" max="10" />
                            </div>

                            <div class="form-group">
                                <label for="force-skin">Force Skin (leave empty for random):</label>
                                <select id="force-skin">
                                    <option value="">Random</option>
                                    <option value="__trail__">Trail (Gold Tier)</option>
                                </select>
                            </div>

                            <div class="flex-wrap">
                                <button class="btn" onclick="simulateUnbox()">Simulate Unbox</button>
                                <button class="btn btn-secondary" onclick="getUserSkins()">Get User Skins</button>
                                <button class="btn btn-secondary" onclick="getAllSkins()">Get All Skins</button>
                            </div>

                            <div class="status-display">
                                <h4>Skin Results:</h4>
                                <pre id="skin-results">No skin tests run yet</pre>
                            </div>
                        </div>

                        <div class="card">
                            <h3 class="card-title">Gift Skin</h3>
                            
                            <div class="form-group">
                                <label for="gift-username">Username:</label>
                                <input type="text" id="gift-username" placeholder="Enter username" />
                            </div>

                            <div class="form-group">
                                <label for="gift-skin">Skin:</label>
                                <select id="gift-skin">
                                    <option value="">Select a skin...</option>
                                </select>
                            </div>

                            <button class="btn btn-success btn-full" onclick="giftSkin()">
                                Gift Skin
                            </button>

                            <div class="status-display">
                                <h4>Gift Results:</h4>
                                <pre id="gift-results">No gifts sent yet</pre>
                            </div>
                        </div>

                        <div class="card">
                            <h3 class="card-title">Submission Queue</h3>

                            <div class="flex-wrap">
                                <button class="btn btn-secondary" onclick="loadSubmissions()">Load Submissions</button>
                                <button class="btn btn-success" onclick="window.open('/skins/submissions', '_blank')">Open Submission Page</button>
                            </div>

                            <div id="submissions-container">
                                <div style="text-align: center; color: #6b7280; padding: 20px;">
                                    Click "Load Submissions" to view pending submissions
                                </div>
                            </div>
                        </div>

                        <div class="card">
                            <h3 class="card-title">Seasonal Skin</h3>

                            <div class="form-group">
                                <label for="seasonal-skin-select">Active Seasonal Skin:</label>
                                <select id="seasonal-skin-select">
                                    <option value="">None (disabled)</option>
                                </select>
                            </div>

                            <div class="flex-wrap">
                                <button class="btn btn-success" onclick="setSeasonalSkin()">Set Seasonal</button>
                                <button class="btn btn-danger" onclick="clearSeasonalSkin()">Clear</button>
                            </div>

                            <p id="seasonal-skin-status" style="margin-top: 10px; color: var(--text-secondary); font-size: 0.875rem;"></p>
                        </div>
                    </div>

                    <!-- Full width skin management card -->
                    <div class="card" style="margin-top: 20px;">
                        <h3 class="card-title">Skin Management</h3>

                        <div class="flex-wrap">
                            <button class="btn" onclick="loadAllSkins()">Refresh Skins</button>
                            <button class="btn btn-warning" onclick="reloadSkinSystem()">Reload System</button>
                        </div>

                        <div id="skins-container" class="skins-grid" style="margin-top: 20px;">
                            <div style="text-align: center; color: #6b7280; padding: 20px;">
                                Loading skins...
                            </div>
                        </div>
                    </div>


                </div>

                <!-- Trail Management Tab -->
                <div id="tab-3" class="tab-content hidden">
                    <div class="grid">
                        <div class="card">
                            <h3 class="card-title">Trail System Controls</h3>
                            
                            <div class="flex-wrap">
                                <button class="btn" onclick="loadAllTrails()">Refresh Trails</button>
                                <button class="btn btn-warning" onclick="reloadTrailSystem()">Reload System</button>
                                <button class="btn btn-info" onclick="previewAllTrails()">Preview All</button>
                            </div>
                            
                            <div class="status-display">
                                <h4>Trail System Status:</h4>
                                <pre id="trail-system-status">Loading...</pre>
                            </div>
                        </div>
                        
                        <div class="card">
                            <h3 class="card-title">Give Trail to User</h3>
                            
                            <div class="form-group">
                                <label for="trail-gift-username">Username:</label>
                                <input type="text" id="trail-gift-username" placeholder="Enter username" />
                            </div>
                            
                            <div class="form-group">
                                <label for="trail-gift-select">Trail:</label>
                                <select id="trail-gift-select">
                                    <option value="">Select a trail...</option>
                                </select>
                            </div>
                            
                            <button class="btn btn-success btn-full" onclick="giveTrailToUser()">Give Trail</button>
                            
                            <div class="status-display">
                                <h4>Trail Actions:</h4>
                                <pre id="trail-actions-results">No actions performed</pre>
                            </div>
                        </div>
                    </div>

                    <!-- Full width trail management card -->
                    <div class="card" style="margin-top: 20px;">
                        <h3 class="card-title">Available Trails</h3>
                        
                        <div id="trails-container" class="trails-grid" style="margin-top: 20px;">
                            <div style="text-align: center; color: #6b7280; padding: 20px;">
                                Loading trails...
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Leaderboard Tab -->
                <div id="tab-4" class="tab-content hidden">
                    <div class="grid">
                        <div class="card">
                            <h3 class="card-title">Leaderboard Management</h3>

                            <div class="form-group">
                                <label for="lb-username">Username:</label>
                                <input type="text" id="lb-username" value="test_user" />
                            </div>

                            <div class="flex-wrap">
                                <button class="btn" onclick="getLeaderboard()">Get Leaderboard</button>
                                <button class="btn btn-secondary" onclick="getLeaderboardStats()">Get Stats</button>
                                <button class="btn btn-secondary" onclick="getUserStats()">Get User Stats</button>
                                <button class="btn btn-success" onclick="generateTestUsers()">Generate Test Users</button>
                                <button class="btn btn-secondary" onclick="showLeaderboard()">Show Leaderboard</button>
                            </div>

                            <div class="grid-2" style="margin-top: 15px;">
                                <button class="btn btn-danger" onclick="resetPlayer()">Reset Player</button>
                                <button class="btn btn-secondary" onclick="clearCache()">Clear Cache</button>
                            </div>

                            <div class="status-display">
                                <h4>Leaderboard Data:</h4>
                                <pre id="leaderboard-results">No data loaded</pre>
                            </div>
                        </div>

                        <div class="card">
                            <h3 class="card-title">Player Management</h3>

                            <div class="form-group">
                                <label for="admin-player-search">Search Players:</label>
                                <input type="text" id="admin-player-search" placeholder="Enter username..." onkeyup="if(event.key==='Enter')adminSearchPlayers()" />
                            </div>

                            <div class="flex-wrap">
                                <button class="btn" onclick="adminSearchPlayers()">Search</button>
                                <button class="btn btn-secondary" onclick="adminLoadAllPlayers()">Load All Players</button>
                            </div>

                            <div class="form-group" style="margin-top: 15px;">
                                <label for="admin-quick-player">Quick Edit/Delete:</label>
                                <input type="text" id="admin-quick-player" placeholder="Enter exact username" />
                            </div>

                            <div class="flex-wrap">
                                <button class="btn btn-info" onclick="adminLoadPlayerForEdit()">Edit Player</button>
                                <button class="btn btn-danger" onclick="adminQuickDeletePlayer()">Delete Player</button>
                            </div>
                        </div>
                    </div>

                    <!-- Full width player list -->
                    <div class="card" style="margin-top: 20px;">
                        <h3 class="card-title">Player List</h3>
                        <div id="admin-players-container" style="max-height: 500px; overflow-y: auto;">
                            <p style="color: var(--text-secondary); text-align: center; padding: 20px;">
                                Click "Load All Players" or search to view players
                            </p>
                        </div>
                        <div id="admin-players-pagination" style="margin-top: 15px; display: flex; justify-content: center; gap: 10px;"></div>
                    </div>
                </div>

                <!-- Announcements Tab -->
                <div id="tab-5" class="tab-content hidden">
                    <div class="grid">
                        <div class="card">
                            <h3 class="card-title">Site Announcement</h3>
                            
                            <div class="form-group">
                                <label for="announcement-enabled">
                                    <input type="checkbox" id="announcement-enabled" />
                                    Enable announcement banner
                                </label>
                            </div>
                            
                            <div class="form-group">
                                <label for="announcement-content">Announcement Content (HTML supported):</label>
                                <textarea 
                                    id="announcement-content" 
                                    placeholder="Enter your announcement here. HTML is supported for links, formatting, etc."
                                    rows="4"
                                    style="width: 100%; padding: 14px 16px; border: 2px solid var(--input-border); border-radius: 10px; font-size: 1rem; background: var(--input-bg); color: var(--text-primary); font-family: inherit; resize: vertical; transition: all 0.3s ease;"
                                ></textarea>
                                <small style="color: var(--text-secondary); font-size: 0.875rem; margin-top: 5px; display: block;">
                                    You can use HTML tags like &lt;a href="url"&gt;link&lt;/a&gt;, &lt;strong&gt;bold&lt;/strong&gt;, &lt;em&gt;italic&lt;/em&gt;, etc.
                                </small>
                            </div>
                            
                            <button class="btn btn-success btn-full" onclick="saveAnnouncement()">
                                Save Announcement
                            </button>
                            
                            <div class="status-display">
                                <h4>Announcement Status:</h4>
                                <pre id="announcement-results">Loading announcement settings...</pre>
                            </div>
                        </div>
                        
                        <div class="card">
                            <h3 class="card-title">Preview</h3>
                            
                            <div class="form-group">
                                <label>Live Preview:</label>
                                <div id="announcement-preview" style="background: #1e40af; color: white; padding: 12px 20px; border-radius: 8px; text-align: center; margin-top: 10px; min-height: 20px; display: none;">
                                    Preview will appear here when enabled
                                </div>
                                <div id="no-announcement-message" style="background: var(--status-bg); border: 1px solid var(--status-border); padding: 12px 20px; border-radius: 8px; text-align: center; margin-top: 10px; color: var(--text-secondary);">
                                    No announcement configured
                                </div>
                            </div>
                            
                            <button class="btn btn-secondary btn-full" onclick="previewAnnouncement()">
                                Update Preview
                            </button>
                        </div>

                        <div class="card">
                            <h3 class="card-title">Follow Reward</h3>
                            <p style="color: var(--text-secondary); margin-bottom: 15px; font-size: 0.9rem;">
                                Give new followers a free coneflip when they follow your channel.
                            </p>

                            <div class="form-group">
                                <label for="follow-reward-enabled">
                                    <input type="checkbox" id="follow-reward-enabled" />
                                    Enable follow reward
                                </label>
                            </div>

                            <div class="form-group">
                                <label for="follow-reward-chat-enabled">
                                    <input type="checkbox" id="follow-reward-chat-enabled" checked />
                                    Send chat message
                                </label>
                            </div>

                            <div class="form-group">
                                <label for="follow-reward-message">Chat Message:</label>
                                <input
                                    type="text"
                                    id="follow-reward-message"
                                    placeholder="@{user} thanks for following! Enjoy a free coneflip!"
                                    value="@{user} thanks for following! Enjoy a free coneflip!"
                                    style="width: 100%; padding: 14px 16px; border: 2px solid var(--input-border); border-radius: 10px; font-size: 1rem; background: var(--input-bg); color: var(--text-primary);"
                                />
                                <small style="color: var(--text-secondary); font-size: 0.875rem; margin-top: 5px; display: block;">
                                    Use <code>{user}</code> as a placeholder for the follower's username.
                                </small>
                            </div>

                            <button class="btn btn-success btn-full" onclick="saveFollowReward()">
                                Save Follow Reward Settings
                            </button>

                            <div class="status-display">
                                <h4>Follow Reward Status:</h4>
                                <pre id="follow-reward-results">Loading follow reward settings...</pre>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Contest Tab -->
                <div id="tab-6" class="tab-content hidden">
                    <div class="grid">
                        <div class="card">
                            <h3 class="card-title">Contest Management</h3>
                            
                            <div class="form-group">
                                <label for="contest-enabled">
                                    <input type="checkbox" id="contest-enabled" />
                                    Enable contest system
                                </label>
                            </div>
                            
                            <div class="form-group">
                                <label for="contest-submissions">
                                    <input type="checkbox" id="contest-submissions" />
                                    Allow contest submissions
                                </label>
                            </div>
                            
                            <div class="form-group">
                                <label for="contest-prize">Contest Prize:</label>
                                <input 
                                    type="text" 
                                    id="contest-prize" 
                                    placeholder="Enter the contest prize (e.g., $100, Steam Gift Card, etc.)"
                                    style="width: 100%; padding: 14px 16px; border: 2px solid var(--input-border); border-radius: 10px; font-size: 1rem; background: var(--input-bg); color: var(--text-primary);"
                                />
                            </div>
                            
                            <div class="form-group">
                                <label for="contest-description">Contest Description:</label>
                                <textarea 
                                    id="contest-description" 
                                    placeholder="Describe the contest rules, theme, deadlines, etc."
                                    rows="4"
                                    style="width: 100%; padding: 14px 16px; border: 2px solid var(--input-border); border-radius: 10px; font-size: 1rem; background: var(--input-bg); color: var(--text-primary); font-family: inherit; resize: vertical; transition: all 0.3s ease;"
                                ></textarea>
                            </div>
                            
                            <button class="btn btn-success btn-full" onclick="saveContest()">
                                Save Contest Settings
                            </button>
                            
                            <div class="status-display">
                                <h4>Contest Status:</h4>
                                <pre id="contest-results">Loading contest settings...</pre>
                            </div>
                        </div>
                        
                        <div class="card">
                            <h3 class="card-title">Contest Entries</h3>
                            
                            <div class="form-group">
                                <button class="btn btn-secondary btn-full" onclick="loadContestEntries()">
                                    View Contest Submissions
                                </button>
                            </div>
                            
                            <div class="form-group" style="margin-top: 15px;">
                                <button class="btn btn-danger btn-full" onclick="resetContestDatabase()" style="background: linear-gradient(135deg, #ef4444, #dc2626);">
                                    üóëÔ∏è Reset Contest Database (Clear All Votes)
                                </button>
                            </div>
                            
                            <div id="contest-entries-container" style="margin-top: 20px;">
                                <div style="text-align: center; color: var(--text-secondary); padding: 20px;">
                                    Click "View Contest Submissions" to load entries
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- System Tab -->
                <div id="tab-7" class="tab-content hidden">
                    <div class="grid">
                        <div class="card">
                            <h3 class="card-title">System Status</h3>

                            <div class="flex-wrap">
                                <button class="btn" onclick="getSystemHealth()">Health Check</button>
                                <button class="btn btn-secondary" onclick="getDatabaseStats()">Database Stats</button>
                                <button class="btn btn-danger" onclick="createBackup()">Create Backup</button>
                                <button class="btn btn-secondary" onclick="getSystemInfo()">System Info</button>
                                <button class="btn btn-danger" onclick="restartGame()">Restart Game</button>
                            </div>

                            <div class="status-display">
                                <h4>System Information:</h4>
                                <pre id="system-results">Click Health Check to load</pre>
                            </div>
                        </div>

                        <div class="card">
                            <h3 class="card-title">Sound Settings</h3>

                            <div class="form-group">
                                <label for="volume-slider">Sound Effect Volume: <span id="volume-value">100</span>%</label>
                                <input type="range" id="volume-slider" min="0" max="100" value="100"
                                    style="width: 100%; cursor: pointer; accent-color: var(--text-link);"
                                    oninput="document.getElementById('volume-value').textContent = this.value" />
                            </div>

                            <button class="btn btn-success" onclick="saveVolumeSettings()">Save Volume</button>

                            <p id="volume-status" style="margin-top: 10px; color: var(--text-secondary); font-size: 0.875rem;"></p>
                        </div>

                        <div class="card">
                            <h3 class="card-title">Chat Message Settings</h3>

                            <div class="form-group">
                                <label for="level-up-chat-enabled">
                                    <input type="checkbox" id="level-up-chat-enabled" />
                                    Enable level up messages in chat
                                </label>
                                <p style="color: var(--text-secondary); font-size: 0.8rem; margin-top: 5px;">
                                    When enabled, announces in Twitch chat when players level up.
                                </p>
                            </div>

                            <button class="btn btn-success" onclick="saveLevelUpChatSettings()">Save Settings</button>

                            <p id="level-up-chat-status" style="margin-top: 10px; color: var(--text-secondary); font-size: 0.875rem;"></p>
                        </div>

                        <div class="card" style="border: 2px solid rgba(239, 68, 68, 0.3); background: linear-gradient(135deg, rgba(239, 68, 68, 0.05) 0%, rgba(185, 28, 28, 0.1) 100%);">
                            <h3 class="card-title" style="color: #ef4444;">DANGER ZONE</h3>
                            <p style="color: var(--text-secondary); margin-bottom: 20px;">
                                These actions are irreversible and will affect ALL players. Use with extreme caution.
                            </p>

                            <button class="btn-nuke" onclick="openNukeModal()" style="width: 100%;">
                                RESET ALL PLAYER SCORES
                            </button>
                            <p style="margin-top: 10px; color: #ef4444; font-size: 0.8rem; text-align: center;">
                                This will reset ALL scores, wins, and losses to 0. Skins will NOT be affected.
                            </p>
                        </div>
                    </div>
                </div>

                <!-- Setup Tab -->
                <div id="tab-9" class="tab-content hidden">
                    <div class="grid">
                        <div class="card">
                            <h3 class="card-title">‚ö†Ô∏è Configuration Setup</h3>
                            <p style="color: var(--text-secondary); margin-bottom: 20px;">Configure your Twitch integration and bot settings. This data is stored securely in setup.json.</p>
                            
                            <div class="setup-field">
                                <label for="twitch-client">Twitch Client ID</label>
                                <input type="text" id="twitch-client" placeholder="Your Twitch application client ID" />
                            </div>



                            <div class="setup-field">
                                <label for="twitch-channel">Twitch Channel</label>
                                <input type="text" id="twitch-channel" placeholder="Your Twitch channel name" />
                            </div>

                            <div class="setup-field">
                                <label for="bot-name">Bot Name</label>
                                <input type="text" id="bot-name" placeholder="Your Twitch bot username" />
                            </div>

                            <div class="setup-field">
                                <label for="twitch-user-id">Twitch User ID</label>
                                <input type="text" id="twitch-user-id" placeholder="Your Twitch user ID" />
                            </div>

                            <div class="twitch-auth-section">
                                <h4 style="margin-bottom: 15px; color: #9146ff;">üîê Get Twitch Tokens</h4>
                                <p style="color: var(--text-secondary); margin-bottom: 15px;">
                                    Use the Twitch Token Generator to get your access tokens. Click the button below to open the generator in a new tab.
                                </p>
                                <div class="flex-wrap" style="gap: 10px;">
                                    <button class="twitch-auth-btn" onclick="openTwitchTokenGenerator()">
                                        üéÆ Open Twitch Token Generator
                                    </button>
                                </div>
                                <p style="color: var(--text-secondary); font-size: 0.875rem; margin-top: 10px;">
                                    <strong>Required Scopes:</strong> chat:read, chat:edit, channel:moderate, channel:read:subscriptions, channel:read:redemptions, channel:manage:redemptions, user:read:chat, user:write:chat, channel:bot
                                </p>
                                <p style="color: var(--text-secondary); font-size: 0.875rem; margin-top: 5px;">
                                    Generate tokens for both your streamer and bot accounts, then paste them in the fields above.
                                </p>
                            </div>

                            <div class="setup-field">
                                <label for="streamer-access-token">Streamer Access Token</label>
                                <div class="token-field">
                                    <input type="password" id="streamer-access-token" placeholder="OAuth token for streamer account" />
                                    <span class="hover-reveal-hint">Hover to reveal</span>
                                </div>
                            </div>

                            <div class="setup-field">
                                <label for="bot-access-token">Bot Access Token</label>
                                <div class="token-field">
                                    <input type="password" id="bot-access-token" placeholder="OAuth token for bot account" />
                                    <span class="hover-reveal-hint">Hover to reveal</span>
                                </div>
                            </div>

                            <div class="setup-field">
                                <label for="twitch-duel-reward">Twitch Duel Reward ID</label>
                                <input type="text" id="twitch-duel-reward" placeholder="Channel point reward ID for duels" />
                            </div>

                            <div class="setup-field">
                                <label for="twitch-cone-reward">Twitch Cone Reward ID</label>
                                <input type="text" id="twitch-cone-reward" placeholder="Channel point reward ID for cone flips" />
                            </div>

                            <div class="setup-field">
                                <label for="twitch-unbox-cone">Twitch Unbox Cone Reward ID</label>
                                <input type="text" id="twitch-unbox-cone" placeholder="Channel point reward ID for unboxing" />
                            </div>

                            <div class="setup-field">
                                <label for="twitch-buy-cone">Twitch Buy Cone Reward ID</label>
                                <input type="text" id="twitch-buy-cone" placeholder="Channel point reward ID for buying cones" />
                            </div>

                            <div class="setup-field optional">
                                <label for="seventv-token">7TV API Token</label>
                                <div class="token-field">
                                    <input type="password" id="seventv-token" placeholder="Optional 7TV API token for emote integration" />
                                    <span class="hover-reveal-hint">Hover to reveal</span>
                                </div>
                            </div>

                            <div class="flex-wrap" style="margin-top: 30px;">
                                <button class="btn btn-success" onclick="saveSetup()">üíæ Save Configuration</button>
                                <button class="btn btn-secondary" onclick="loadSetup()">üîÑ Load Configuration</button>
                                <button class="btn btn-warning" onclick="testConfiguration()">üß™ Test Configuration</button>
                            </div>

                            <div class="status-display">
                                <h4>Configuration Status:</h4>
                                <pre id="setup-results">Configuration not loaded</pre>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Moderators Tab -->
                <div id="tab-8" class="tab-content hidden">
                    <div class="grid">
                        <div class="card">
                            <h3 class="card-title">Moderator Management</h3>
                            <p style="color: var(--text-secondary); margin-bottom: 20px;">
                                Manage users who can access the Mod Panel. Moderators can test games, manage skins, trails, announcements, and contests.
                            </p>

                            <div class="form-group">
                                <label for="new-moderator">Add Moderator (Twitch Username):</label>
                                <div style="display: flex; gap: 10px;">
                                    <input type="text" id="new-moderator" placeholder="Enter Twitch username" style="flex: 1;" />
                                    <button class="btn btn-success" onclick="addModerator()">Add</button>
                                </div>
                            </div>

                            <div class="status-display" style="margin-top: 20px;">
                                <h4>Current Moderators:</h4>
                                <div id="moderators-list" style="margin-top: 10px;">
                                    <p style="color: var(--text-secondary);">Loading...</p>
                                </div>
                            </div>

                            <div class="flex-wrap" style="margin-top: 20px;">
                                <button class="btn btn-secondary" onclick="loadModerators()">üîÑ Refresh List</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Warning Overlay -->
    <div id="warning-overlay" class="warning-overlay hidden">
        <div class="warning-modal">
            <div class="warning-icon">‚ö†Ô∏è</div>
            <h2 style="color: #ef4444; margin-bottom: 15px;">Sensitive Data Warning</h2>
            <p style="margin-bottom: 20px; line-height: 1.5;">
                This page contains sensitive configuration data including API tokens and access credentials. 
                Make sure you're in a secure environment and no one else can see your screen.
            </p>
            <div class="flex-wrap">
                <button class="btn btn-danger" onclick="acknowledgeWarning()">I Understand - Continue</button>
                <button class="btn btn-secondary" onclick="goBackFromSetup()">Go Back</button>
            </div>
        </div>
    </div>

    <!-- Notification -->
    <!-- Approval Configuration Modal -->
    <div id="approvalModal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Configure Skin Approval</h3>
                <button class="btn btn-small btn-secondary" onclick="closeApprovalModal()">√ó</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>Submission Name:</label>
                    <input type="text" id="approvalSubmissionName" placeholder="Enter skin name..." />
                </div>
                
                <div class="form-group">
                    <label for="approvalCanUnbox">
                        <input type="checkbox" id="approvalCanUnbox" />
                        Can be unboxed
                    </label>
                </div>
                
                <div class="form-group" id="approvalWeightGroup">
                    <label for="approvalUnboxWeight">Unbox Weight (rarity):</label>
                    <input type="number" id="approvalUnboxWeight" min="1" max="100" value="15" />
                                                <small style="color: #6b7280;">Tier ranges: ‚â•30 = Mil-Spec (72.54%), ‚â•15 = Restricted (18%), ‚â•9 = Classified (6.8%), ‚â•5 = Covert (2.4%), <5 = Gold (0.26%)</small>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeApprovalModal()">Cancel</button>
                <button class="btn btn-success" onclick="confirmApproval()">Approve Skin</button>
            </div>
        </div>
    </div>

    <!-- Skin Edit Modal -->
    <div id="editSkinModal" class="modal hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Edit Skin</h3>
                <button class="btn btn-small btn-secondary" onclick="closeEditSkinModal()">√ó</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>Skin Name:</label>
                    <input type="text" id="editSkinName" placeholder="Enter skin name..." />
                </div>
                
                <div class="form-group">
                    <label for="editCanUnbox">
                        <input type="checkbox" id="editCanUnbox" />
                        Can be unboxed
                    </label>
                </div>
                
                <div class="form-group" id="unboxWeightGroup">
                    <label for="editUnboxWeight">Unbox Weight:</label>
                    <input type="number" id="editUnboxWeight" min="0" max="100" />
                                                <small>Tier ranges: ‚â•30 = Mil-Spec (72.54%), ‚â•15 = Restricted (18%), ‚â•9 = Classified (6.8%), ‚â•5 = Covert (2.4%), <5 = Gold (0.26%)</small>
                </div>
                
                <div class="form-group">
                    <button class="btn btn-success" onclick="saveSkinEdit()">Save Changes</button>
                    <button class="btn btn-secondary" onclick="closeEditSkinModal()">Cancel</button>
                </div>
            </div>
        </div>
    </div>



    <!-- Fullscreen Image Modal -->
    <div id="fullscreenModal" class="modal hidden">
        <div class="modal-content" style="max-width: 90vw; max-height: 90vh; padding: 0; background: transparent; box-shadow: none;">
            <div class="modal-header" style="position: absolute; top: 10px; right: 10px; z-index: 1001; background: rgba(0,0,0,0.7); border-radius: 50%; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center;">
                <button class="btn btn-small btn-secondary" onclick="closeFullscreenModal()" style="background: transparent; border: none; color: white; font-size: 20px; padding: 0;">√ó</button>
            </div>
            <div class="modal-body" style="padding: 0; text-align: center;">
                <img id="fullscreenImage" src="" alt="Fullscreen Preview" style="max-width: 100%; max-height: 90vh; object-fit: contain; border-radius: 8px;">
            </div>
        </div>
    </div>

    <!-- Nuclear Reset Modal -->
    <div id="nukeModal" class="modal hidden">
        <div class="modal-content nuke-modal-content">
            <div class="nuke-modal-body">
                <!-- Step 1: Initial Warning -->
                <div id="nuke-step-1" class="nuke-step active">
                    <div class="nuke-icon">&#9762;</div>
                    <div class="nuke-title">NUCLEAR OPTION</div>
                    <div class="nuke-message">
                        You are about to <strong>RESET ALL PLAYER SCORES</strong>.<br><br>
                        This will set everyone's points, wins, losses, and streaks to <strong>ZERO</strong>.<br>
                        (Don't worry, skins are safe!)
                    </div>
                    <div class="nuke-buttons">
                        <button class="btn-nuke" onclick="nukeStep(2)">Yes, I'm sure</button>
                        <button class="btn-chicken" onclick="closeNukeModal()">Nevermind, I'm scared</button>
                    </div>
                </div>

                <!-- Step 2: Personal Call-out -->
                <div id="nuke-step-2" class="nuke-step">
                    <div class="nuke-icon">&#129300;</div>
                    <div class="nuke-title">HOLD UP...</div>
                    <div class="nuke-message">
                        <span class="streamer-name-highlight" id="streamer-callout">Streamer</span>, are you REALLY sure you want to do this?<br><br>
                        Think about all those players who worked so hard for their scores...<br>
                        Their dreams... their grind... their dedication...
                    </div>
                    <div class="nuke-buttons">
                        <button class="btn-nuke" onclick="nukeStep(3)">I have no mercy</button>
                        <button class="btn-chicken" onclick="closeNukeModal()">Okay maybe I'll reconsider...</button>
                    </div>
                </div>

                <!-- Step 3: Final Warning -->
                <div id="nuke-step-3" class="nuke-step">
                    <div class="nuke-icon">&#128163;</div>
                    <div class="nuke-title">FINAL WARNING</div>
                    <div class="nuke-message">
                        <strong style="color: #ef4444; font-size: 1.3rem;">TACTICAL NUKE INCOMING!</strong><br><br>
                        Pressing the button below will:<br>
                        &#128165; Reset ALL scores to 0<br>
                        &#128165; Reset ALL wins and losses to 0<br>
                        &#128165; Reset ALL streaks to 0<br>
                        &#128165; Obliterate the entire leaderboard<br><br>
                        <em style="color: #22c55e;">Skins will remain untouched.</em>
                    </div>
                    <div class="nuke-buttons">
                        <button class="btn-nuke" onclick="launchNuke()" style="animation: pulse 0.5s ease-in-out infinite;">
                            &#128640; LAUNCH THE NUKE &#128640;
                        </button>
                        <button class="btn-chicken" onclick="closeNukeModal()">I've changed my mind!</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Nuke Countdown Overlay -->
    <div id="nukeOverlay" class="nuke-overlay">
        <div class="nuke-warning-text">TACTICAL NUKE INCOMING</div>
        <div id="nukeCountdown" class="nuke-countdown">5</div>
    </div>

    <!-- Nuke Explosion Effect -->
    <div id="nukeExplosion" class="nuke-explosion"></div>

    <div id="notification" class="hidden"></div>

    <!-- Edit Player Modal -->
    <div id="adminEditPlayerModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); backdrop-filter: blur(5px); z-index: 2000; align-items: center; justify-content: center;">
        <div class="modal-content" style="background: var(--card-bg); border-radius: 16px; max-width: 600px; width: 90%; max-height: 90vh; overflow-y: auto; border: 1px solid var(--card-border);">
            <div style="padding: 20px; border-bottom: 1px solid var(--card-border); display: flex; justify-content: space-between; align-items: center;">
                <h3 style="margin: 0;">Edit Player Stats: <span id="adminEditPlayerName"></span></h3>
                <button class="btn btn-small btn-secondary" onclick="closeAdminEditPlayerModal()">√ó</button>
            </div>
            <div style="padding: 20px;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <div class="form-group">
                        <label for="adminEditPoints">Points:</label>
                        <input type="number" id="adminEditPoints" min="0" />
                    </div>
                    <div class="form-group">
                        <label for="adminEditLevel">Level:</label>
                        <input type="number" id="adminEditLevel" min="1" />
                    </div>
                    <div class="form-group">
                        <label for="adminEditXp">XP:</label>
                        <input type="number" id="adminEditXp" min="0" />
                    </div>
                    <div class="form-group">
                        <label for="adminEditWins">Total Wins:</label>
                        <input type="number" id="adminEditWins" min="0" />
                    </div>
                    <div class="form-group">
                        <label for="adminEditFails">Total Fails:</label>
                        <input type="number" id="adminEditFails" min="0" />
                    </div>
                    <div class="form-group">
                        <label for="adminEditDuelWins">Duel Wins:</label>
                        <input type="number" id="adminEditDuelWins" min="0" />
                    </div>
                    <div class="form-group">
                        <label for="adminEditDuelLosses">Duel Losses:</label>
                        <input type="number" id="adminEditDuelLosses" min="0" />
                    </div>
                    <div class="form-group">
                        <label for="adminEditConeflipWins">Coneflip Wins:</label>
                        <input type="number" id="adminEditConeflipWins" min="0" />
                    </div>
                    <div class="form-group">
                        <label for="adminEditConeflipLosses">Coneflip Losses:</label>
                        <input type="number" id="adminEditConeflipLosses" min="0" />
                    </div>
                    <div class="form-group">
                        <label for="adminEditCurrentStreak">Current Streak:</label>
                        <input type="number" id="adminEditCurrentStreak" min="0" />
                    </div>
                    <div class="form-group">
                        <label for="adminEditHighestStreak">Highest Streak:</label>
                        <input type="number" id="adminEditHighestStreak" min="0" />
                    </div>
                </div>
            </div>
            <div style="padding: 20px; border-top: 1px solid var(--card-border); display: flex; justify-content: flex-end; gap: 10px;">
                <button class="btn btn-secondary" onclick="closeAdminEditPlayerModal()">Cancel</button>
                <button class="btn btn-danger" onclick="adminDeletePlayerFromModal()">Delete Player</button>
                <button class="btn btn-success" onclick="adminSavePlayerStats()">Save Changes</button>
            </div>
        </div>
    </div>

    <script>
        let adminToken = '';
        let tokenData = null;
        let sessionRefreshInterval = null;

        // Player Management Variables
        let adminCurrentEditPlayer = null;
        let adminCurrentPlayersPage = 1;

        // Initialize the dashboard
        document.addEventListener('DOMContentLoaded', async function() {
            // Initialize theme first before anything else
            initTheme();

            // Check if user is authenticated via session
            await checkAuthStatus();

            // Add Enter key handler for user stats input
            document.getElementById('user-stats-username').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    getUserStats();
                }
            });

            // Set Leaderboard and Unbox URLs
            const leaderboardUrl = document.getElementById('obs-leaderboard-url');
            if (leaderboardUrl) leaderboardUrl.textContent = `${window.location.origin}/leaderboard`;
            const unboxUrl = document.getElementById('obs-unbox-url');
            if (unboxUrl) unboxUrl.textContent = `${window.location.origin}/unbox`;
            
            // Check for auth success/error URL parameters
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('auth_success')) {
                showAuthMessage('Successfully logged in!', 'success');
                // Clean URL
                window.history.replaceState({}, document.title, window.location.pathname);
            } else if (urlParams.get('auth_error')) {
                const error = urlParams.get('auth_error');
                showAuthError(getAuthErrorMessage(error));
                // Clean URL
                window.history.replaceState({}, document.title, window.location.pathname);
            }
        });

        // Check authentication status via session
        async function checkAuthStatus() {
            try {
                const response = await fetch('/auth/user', {
                    credentials: 'include'
                });
                const data = await response.json();
                
                console.log('Auth check response:', data);

                if (data.status === 'success' && data.data && data.data.is_admin) {
                    // User is authenticated and is admin
                    document.getElementById('login-section').classList.add('hidden');
                    document.getElementById('dashboard').classList.remove('hidden');
                    document.getElementById('auth-error').classList.add('hidden');
                    connectAdminSocket();
                    await loadTokenData();
                    checkTwitchConnections();
                } else if (data.data && !data.data.is_admin) {
                    // User is authenticated but not admin
                    showAuthError('You do not have admin access to this panel.');
                } else {
                    // User is not authenticated
                    document.getElementById('login-section').classList.remove('hidden');
                    document.getElementById('dashboard').classList.add('hidden');
                }
            } catch (error) {
                console.error('Error checking auth status:', error);
                document.getElementById('login-section').classList.remove('hidden');
                document.getElementById('dashboard').classList.add('hidden');
            }
        }

        // Login with Twitch OAuth
        function loginWithTwitch() {
            window.location.href = '/auth/login';
        }

        function showAuthError(message) {
            const errorDiv = document.getElementById('auth-error');
            errorDiv.textContent = message;
            errorDiv.classList.remove('hidden');
        }

        function showAuthMessage(message, type = 'success') {
            const errorDiv = document.getElementById('auth-error');
            errorDiv.textContent = message;
            errorDiv.className = `alert alert-${type}`;
            errorDiv.classList.remove('hidden');
            
            // Hide after 3 seconds for success messages
            if (type === 'success') {
                setTimeout(() => {
                    errorDiv.classList.add('hidden');
                }, 3000);
            }
        }

        function getAuthErrorMessage(error) {
            switch (error) {
                case 'access_denied':
                    return 'Authentication was cancelled.';
                case 'missing_code':
                    return 'Authentication failed - missing authorization code.';
                case 'callback_failed':
                    return 'Authentication failed - please try again.';
                default:
                    return 'Authentication failed - unknown error.';
            }
        }

        // Helper function for API requests (now uses session-based auth)
        async function apiRequest(endpoint, method = 'GET', body = null, queryParams = null) {
            let url = endpoint;
            
            // Add query parameters if provided
            if (queryParams) {
                const params = new URLSearchParams(queryParams);
                url += (endpoint.includes('?') ? '&' : '?') + params.toString();
            }
            
            const options = {
                method,
                headers: {
                    'Content-Type': 'application/json'
                },
                credentials: 'include' // Include session cookies
            };

            if (body && method !== 'GET') {
                options.body = JSON.stringify(body);
            }

            const response = await fetch(url, options);
            
            // If we get 401, user is not authenticated
            if (response.status === 401) {
                window.location.href = '/auth/login';
                return;
            }
            
            // If we get 403, user doesn't have admin access
            if (response.status === 403) {
                showAuthError('You do not have admin access to this panel.');
                return;
            }
            
            return await response.json();
        }

        // Token Management Functions
        async function loadTokenData() {
            try {
                // Show refresh indicator
                const refreshIndicator = document.getElementById('status-refresh-indicator');
                if (refreshIndicator) {
                    refreshIndicator.style.display = 'inline';
                }

                const data = await apiRequest('/api/debug/token/status');
                const previousInUse = tokenData ? tokenData.inUse : false;
                const previousBrowser = tokenData?.info?.browserInfo?.name;
                
                tokenData = data.data;
                updateTokenDisplay();
                
                // Show notification if status changed
                if (tokenData.inUse !== previousInUse) {
                    if (tokenData.inUse) {
                        const browserInfo = tokenData.info?.browserInfo;
                        const browserText = browserInfo ? `${browserInfo.name}${browserInfo.version !== 'Unknown' ? ' ' + browserInfo.version : ''}` : 'Unknown Browser';
                        showNotification(`Token now in use by ${browserText}`, 'success');
                    } else {
                        showNotification('Token is now available', 'success');
                    }
                } else if (tokenData.inUse && previousBrowser && tokenData.info?.browserInfo?.name !== previousBrowser) {
                    // Browser changed while token was in use
                    const browserInfo = tokenData.info?.browserInfo;
                    const browserText = browserInfo ? `${browserInfo.name}${browserInfo.version !== 'Unknown' ? ' ' + browserInfo.version : ''}` : 'Unknown Browser';
                    showNotification(`Browser changed to ${browserText}`, 'success');
                }

                // Hide refresh indicator
                if (refreshIndicator) {
                    setTimeout(() => {
                        refreshIndicator.style.display = 'none';
                    }, 500);
                }
                
                return tokenData; // Return the token data for promise chain
            } catch (error) {
                console.error('Failed to load token data:', error);
                // Hide refresh indicator on error
                const refreshIndicator = document.getElementById('status-refresh-indicator');
                if (refreshIndicator) {
                    refreshIndicator.style.display = 'none';
                }
                throw error; // Re-throw error for promise chain
            }
        }

        function updateTokenDisplay() {
            if (!tokenData) return;

            document.getElementById('current-token').textContent = tokenData.token;
            
            // Update OBS URLs
            document.getElementById('obs-game-url').textContent = `${window.location.origin}/?token=${tokenData.token}`;
            
            // Update status and static URLs
            updateStaticUrls();
        }

        function updateStaticUrls() {
            // Update static URLs that don't need token
            const leaderboardUrl = document.getElementById('obs-leaderboard-url');
            if (leaderboardUrl) {
                leaderboardUrl.textContent = `${window.location.origin}/leaderboard`;
            }
            
            const unboxUrl = document.getElementById('obs-unbox-url');
            if (unboxUrl) {
                unboxUrl.textContent = `${window.location.origin}/unbox`;
            }
            
            const statusElement = document.getElementById('token-status');
            const browserInfoSection = document.getElementById('browser-info-section');
            const browserNameElement = document.getElementById('browser-name');
            const browserTypeElement = document.getElementById('browser-type');
            const lastUpdatedElement = document.getElementById('last-updated');
            
            // Update last updated timestamp
            if (lastUpdatedElement) {
                const now = new Date();
                lastUpdatedElement.textContent = now.toLocaleTimeString();
            }
            
            if (tokenData && statusElement) {
                console.log('Updating status with token data:', {
                    inUse: tokenData.inUse,
                    browserInfo: tokenData.info?.browserInfo
                });
                
                if (tokenData.inUse) {
                    // Show browser info when token is in use
                    const browserInfo = tokenData.info?.browserInfo;
                    if (browserInfo) {
                        const browserText = `${browserInfo.name}${browserInfo.version !== 'Unknown' ? ' ' + browserInfo.version : ''}`;
                        statusElement.textContent = `In Use (${browserText})`;
                        statusElement.title = `Client: ${browserText}\nType: ${browserInfo.type}`;
                        
                        // Show and populate browser info section
                        if (browserInfoSection) browserInfoSection.style.display = 'block';
                        if (browserNameElement) browserNameElement.textContent = browserText;
                        if (browserTypeElement) {
                            browserTypeElement.textContent = browserInfo.type;
                            
                            // Color code the browser type
                            if (browserInfo.type === 'Streaming Software') {
                                browserTypeElement.style.background = 'rgba(168, 85, 247, 0.2)';
                                browserTypeElement.style.color = '#a855f7';
                                browserTypeElement.style.borderColor = '#a855f7';
                            } else {
                                browserTypeElement.style.background = 'rgba(59, 130, 246, 0.2)';
                                browserTypeElement.style.color = '#3b82f6';
                                browserTypeElement.style.borderColor = '#3b82f6';
                            }
                        }
                    } else {
                        statusElement.textContent = 'In Use';
                        statusElement.title = '';
                        if (browserInfoSection) browserInfoSection.style.display = 'none';
                    }
                    statusElement.className = 'chip chip-warning';
                    console.log('Status set to In Use');
                } else {
                    statusElement.textContent = 'Available';
                    statusElement.className = 'chip chip-success';
                    statusElement.title = '';
                    if (browserInfoSection) browserInfoSection.style.display = 'none';
                    console.log('Status set to Available');
                }
            } else {
                console.log('Token data or status element missing:', {
                    hasTokenData: !!tokenData,
                    hasStatusElement: !!statusElement
                });
            }
        }

        async function revokeToken() {
            if (!confirm('Are you sure you want to revoke the current token?')) return;

            try {
                const data = await apiRequest('/api/debug/token/revoke', 'POST');
                tokenData.token = data.data.newToken;
                tokenData.inUse = false;
                updateTokenDisplay();
                showNotification('Token revoked and regenerated successfully', 'success');
            } catch (error) {
                showNotification('Failed to revoke token', 'error');
            }
        }

        // Game Testing Functions
        async function simulateCone() {
            const playerName = document.getElementById('test-player-name').value;
            const skin = document.getElementById('test-skin').value;

            if (!playerName) {
                showNotification('Player name is required', 'error');
                return;
            }

            try {
                // If skin is specified, set it first
                if (skin) {
                    await apiRequest('/api/skins/give', 'POST', {
                        username: playerName,
                        skin: skin
                    });
                }
                
                // Use proper game endpoint that lets physics determine outcome
                const result = await apiRequest('/api/game/cone/add', 'GET', null, {
                    name: playerName
                });
                
                document.getElementById('game-results').textContent = JSON.stringify(result, null, 2);
                showNotification(`Added cone for ${playerName} (outcome determined by physics)`, 'success');
            } catch (error) {
                showNotification('Failed to add cone', 'error');
                console.error('Cone add error:', error);
            }
        }

        async function simulateDuel() {
            const player1 = document.getElementById('test-player-name').value;
            const player2 = document.getElementById('duel-target').value;

            if (!player1) {
                showNotification('Player name is required', 'error');
                return;
            }

            if (!player2) {
                showNotification('Duel target is required', 'error');
                return;
            }

            try {
                const result = await apiRequest('/api/debug/simulate/duel', 'POST', {
                    player1: player1,
                    player2: player2
                });
                document.getElementById('game-results').textContent = JSON.stringify(result, null, 2);
                showNotification(`Simulated duel: ${player1} vs ${player2}`, 'success');
            } catch (error) {
                showNotification('Failed to simulate duel', 'error');
            }
        }

        async function bulkConeFlips() {
            const count = document.getElementById('bulk-count').value;
            try {
                const promises = [];
                // Create multiple real cones that use physics
                for (let i = 0; i < parseInt(count); i++) {
                    promises.push(
                        apiRequest(`/api/game/cone/add?name=BulkTestUser_${i}`)
                    );
                }
                
                const results = await Promise.all(promises);
                document.getElementById('bulk-results').textContent = JSON.stringify({
                    count: results.length,
                    note: "Cones added - outcomes determined by physics"
                }, null, 2);
                showNotification(`Added ${count} cones for physics testing`, 'success');
            } catch (error) {
                showNotification('Failed to run bulk test', 'error');
            }
        }

        async function stressTest() {
            const count = document.getElementById('bulk-count').value;
            const promises = [];
            
            try {
                // Run multiple concurrent real cones with physics
                for (let i = 0; i < parseInt(count); i++) {
                    promises.push(
                        apiRequest(`/api/game/cone/add?name=StressTest_${i}`)
                    );
                }
                
                const results = await Promise.all(promises);
                const summary = {
                    total: results.length,
                    note: "Real cones added - outcomes will be determined by physics"
                };
                
                document.getElementById('bulk-results').textContent = JSON.stringify(summary, null, 2);
                showNotification(`Stress test started: ${count} real cones with physics`, 'success');
            } catch (error) {
                showNotification('Failed to run stress test', 'error');
            }
        }

        // Skin Functions
        async function simulateUnbox() {
            const username = document.getElementById('skin-username').value;
            const count = document.getElementById('unbox-count').value;
            const forceSkin = document.getElementById('force-skin').value || null;

            try {
                const body = {
                    name: username,
                    count: parseInt(count)
                };
                if (forceSkin) body.forceSkin = forceSkin;

                const result = await apiRequest('/api/debug/simulate/unbox', 'POST', body);
                document.getElementById('skin-results').textContent = JSON.stringify(result, null, 2);
                const label = forceSkin ? ` (forced: ${forceSkin})` : '';
                showNotification(`Simulated ${count} unbox(es) for ${username}${label}`, 'success');
            } catch (error) {
                showNotification('Failed to simulate unbox', 'error');
            }
        }

        async function getUserSkins() {
            const username = document.getElementById('skin-username').value;
            try {
                const result = await apiRequest(`/api/skins/user/${username}`);
                document.getElementById('skin-results').textContent = JSON.stringify(result, null, 2);
                showNotification(`Retrieved skins for ${username}`, 'success');
            } catch (error) {
                showNotification('Failed to get user skins', 'error');
            }
        }

        async function getAllSkins() {
            try {
                const result = await apiRequest('/api/skins/available');
                document.getElementById('skin-results').textContent = JSON.stringify(result, null, 2);
                showNotification('Retrieved all available skins', 'success');
            } catch (error) {
                showNotification('Failed to get all skins', 'error');
            }
        }

        // Skin Management Functions
        async function loadAllSkins() {
            try {
                const result = await apiRequest('/api/debug/skins/list');
                const container = document.getElementById('skins-container');
                const giftSelect = document.getElementById('gift-skin');
                
                if (result.data && result.data.length > 0) {
                                            // Sort skins by tier (Gold > Covert > Classified > Restricted > Mil-Spec > Special)
                    const sortedSkins = result.data.sort((a, b) => {
                        const getTierOrder = (weight, canUnbox) => {
                            if (!canUnbox) return 0; // Special tier (highest priority)
                            if (weight < 5) return 1; // Gold
                            if (weight < 9) return 2; // Covert
                            if (weight < 15) return 3; // Classified
                            if (weight < 30) return 4; // Restricted
                            return 5; // Mil-Spec
                        };
                        
                        const aTier = getTierOrder(a.unboxWeight || 0, a.canUnbox);
                        const bTier = getTierOrder(b.unboxWeight || 0, b.canUnbox);
                        
                        if (aTier !== bTier) return aTier - bTier;
                        return a.name.localeCompare(b.name); // Secondary sort by name
                    });
                    
                    // Populate skin management list
                    container.innerHTML = sortedSkins.map(skin => `
                        <div class="skin-item">
                            <div class="skin-info">
                                <div class="skin-preview" style="background-image: url('/skins/${skin.filename}')" onclick="openFullscreenModal('/skins/${skin.filename}', '${skin.name}')"></div>
                                <div class="skin-details">
                                    <h4>${skin.name} ${skin.isHolo ? '(Holo)' : '(Cone)'}</h4>
                                    <p>File: ${skin.filename}</p>
                                    <p>Unboxable: ${skin.canUnbox ? 'Yes' : 'No'}</p>
                                    ${skin.canUnbox ? `<p>Weight: ${skin.unboxWeight || 0} (${getTierFromWeight(skin.unboxWeight || 0)})</p>` : ''}
                                    <p>Status: ${skin.enabled ? 'Enabled' : 'Disabled'}</p>
                                </div>
                            </div>
                            <div class="skin-actions">
                                <button class="btn btn-small btn-secondary" onclick="editSkin('${skin.originalName || skin.name}')">
                                    Edit
                                </button>
                                <button class="btn btn-small ${skin.enabled ? 'btn-secondary' : 'btn-success'}" 
                                        onclick="toggleSkin('${skin.originalName || skin.name}', ${!skin.enabled})">
                                    ${skin.enabled ? 'Disable' : 'Enable'}
                                </button>
                                <button class="btn btn-small btn-danger" onclick="deleteSkin('${skin.originalName || skin.name}')">
                                    Delete
                                </button>
                            </div>
                        </div>
                    `).join('');

                    // Populate gift skin dropdown
                    giftSelect.innerHTML = '<option value="">Select a skin...</option>' +
                        result.data.map(skin => `
                            <option value="${skin.originalName || skin.name}">${skin.name} ${skin.isHolo ? '(Holo)' : '(Cone)'}</option>
                        `).join('');

                    // Populate force skin dropdown for rigged unbox
                    const forceSelect = document.getElementById('force-skin');
                    if (forceSelect) {
                        forceSelect.innerHTML = '<option value="">Random</option>' +
                            '<option value="__trail__">Trail (Gold Tier)</option>' +
                            result.data.filter(s => s.canUnbox).map(skin => `
                                <option value="${skin.originalName || skin.name}">${skin.name}</option>
                            `).join('');
                    }

                    // Populate seasonal skin dropdown
                    const seasonalSelect = document.getElementById('seasonal-skin-select');
                    if (seasonalSelect) {
                        seasonalSelect.innerHTML = '<option value="">None (disabled)</option>' +
                            result.data.map(skin => `
                                <option value="${skin.originalName || skin.name}">${skin.name} ${skin.isHolo ? '(Holo)' : '(Cone)'}</option>
                            `).join('');
                    }
                } else {
                    container.innerHTML = '<div style="text-align: center; color: #6b7280; padding: 20px;">No skins found</div>';
                    giftSelect.innerHTML = '<option value="">No skins available</option>';
                }
                
                showNotification('Skins loaded successfully', 'success');
            } catch (error) {
                showNotification('Failed to load skins', 'error');
                document.getElementById('skins-container').innerHTML = '<div style="text-align: center; color: #6b7280; padding: 20px;">Failed to load skins</div>';
            }
        }

        async function toggleSkin(skinName, enable) {
            try {
                const result = await apiRequest('/api/debug/skins/toggle', 'POST', {
                    name: skinName,
                    enabled: enable
                });
                
                showNotification(`Skin ${enable ? 'enabled' : 'disabled'} successfully`, 'success');
                loadAllSkins(); // Refresh the list
            } catch (error) {
                showNotification(`Failed to ${enable ? 'enable' : 'disable'} skin`, 'error');
            }
        }

        async function deleteSkin(skinName) {
            if (!confirm(`Are you sure you want to delete the skin "${skinName}"? This cannot be undone.`)) return;

            try {
                const result = await apiRequest('/api/debug/skins/delete', 'POST', {
                    name: skinName
                });
                
                showNotification('Skin deleted successfully', 'success');
                loadAllSkins(); // Refresh the list
            } catch (error) {
                showNotification('Failed to delete skin', 'error');
            }
        }

        async function loadSubmissions() {
            try {
                const result = await apiRequest('/api/debug/skins/submissions');
                const container = document.getElementById('submissions-container');
                
                if (result.data && result.data.length > 0) {
                    container.innerHTML = result.data.map(submission => `
                        <div class="submission-item">
                            <div class="submission-header">
                                <div class="submission-info">
                                    <h4>${submission.name} ${submission.isHolo ? '(Holo)' : '(Cone)'}</h4>
                                    <p>Author: ${submission.author}</p>
                                    <p>Uploaded: ${new Date(submission.uploadedAt).toLocaleString()}</p>
                                    <p>File: ${submission.filename}</p>
                                </div>
                            </div>
                            <div class="submission-preview" style="background-image: url('/uploads/submissions/${submission.filename}')" onclick="openFullscreenModal('/uploads/submissions/${submission.filename}', '${submission.name}')"></div>
                            <div class="submission-actions">
                                <button class="btn btn-small btn-success" onclick="approveSubmission('${submission.id}')">
                                    Approve
                                </button>
                                <button class="btn btn-small btn-danger" onclick="rejectSubmission('${submission.id}')">
                                    Reject
                                </button>
                            </div>
                        </div>
                    `).join('');
                } else {
                    container.innerHTML = '<div style="text-align: center; color: #6b7280; padding: 20px;">No pending submissions</div>';
                }
                
                showNotification('Submissions loaded successfully', 'success');
            } catch (error) {
                showNotification('Failed to load submissions', 'error');
            }
        }

        let currentApprovalId = null;

        async function approveSubmission(submissionId) {
            // Find the submission to get its name
            const submissions = await getCurrentSubmissions();
            const submission = submissions.find(s => s.id === submissionId);
            
            if (!submission) {
                showNotification('Submission not found', 'error');
                return;
            }

            // Store the ID and show the modal
            currentApprovalId = submissionId;
            document.getElementById('approvalSubmissionName').value = submission.name;
            document.getElementById('approvalCanUnbox').checked = false;
            document.getElementById('approvalUnboxWeight').value = 15;
            document.getElementById('approvalModal').classList.remove('hidden');
        }

        async function getCurrentSubmissions() {
            try {
                const result = await apiRequest('/api/debug/skins/submissions');
                return result.data || [];
            } catch (error) {
                return [];
            }
        }

        function closeApprovalModal() {
            document.getElementById('approvalModal').classList.add('hidden');
            currentApprovalId = null;
        }

        async function confirmApproval() {
            if (!currentApprovalId) return;

            try {
                const newName = document.getElementById('approvalSubmissionName').value.trim();
                const canUnbox = document.getElementById('approvalCanUnbox').checked;
                const unboxWeight = parseInt(document.getElementById('approvalUnboxWeight').value);

                if (!newName) {
                    showNotification('Please enter a valid skin name', 'error');
                    return;
                }

                // First update the submission name if it changed
                const submissions = await getCurrentSubmissions();
                const submission = submissions.find(s => s.id === currentApprovalId);
                
                if (submission && submission.name !== newName) {
                    try {
                        await apiRequest('/api/debug/skins/submissions/update-name', 'POST', {
                            id: currentApprovalId,
                            newName: newName
                        });
                    } catch (nameError) {
                        showNotification('Failed to update submission name', 'error');
                        return;
                    }
                }

                // Then approve the submission
                const result = await apiRequest('/api/debug/skins/submissions/approve', 'POST', {
                    id: currentApprovalId,
                    canUnbox: canUnbox,
                    unboxWeight: canUnbox ? unboxWeight : 0
                });
                
                showNotification('Submission approved successfully', 'success');
                closeApprovalModal();
                loadSubmissions(); // Refresh submissions
                loadAllSkins(); // Refresh skins list
            } catch (error) {
                showNotification('Failed to approve submission', 'error');
            }
        }

        async function rejectSubmission(submissionId) {
            if (!confirm('Are you sure you want to reject this submission?')) return;

            try {
                const result = await apiRequest('/api/debug/skins/submissions/reject', 'POST', {
                    id: submissionId
                });
                
                showNotification('Submission rejected', 'success');
                loadSubmissions(); // Refresh submissions
            } catch (error) {
                showNotification('Failed to reject submission', 'error');
            }
        }



        // Leaderboard Functions
        async function getLeaderboard() {
            try {
                const result = await apiRequest('/api/leaderboard');
                document.getElementById('leaderboard-results').textContent = JSON.stringify(result, null, 2);
                showNotification('Retrieved leaderboard data', 'success');
            } catch (error) {
                showNotification('Failed to get leaderboard', 'error');
            }
        }

        async function getLeaderboardStats() {
            try {
                const result = await apiRequest('/api/leaderboard/stats');
                document.getElementById('leaderboard-results').textContent = JSON.stringify(result, null, 2);
                showNotification('Retrieved leaderboard stats', 'success');
            } catch (error) {
                showNotification('Failed to get leaderboard stats', 'error');
            }
        }

        async function generateTestUsers() {
            try {
                const result = await apiRequest('/api/debug/populate/users', 'POST');
                document.getElementById('leaderboard-results').textContent = JSON.stringify(result, null, 2);
                showNotification('Generated test users', 'success');
            } catch (error) {
                showNotification('Failed to generate test users', 'error');
            }
        }

        async function showLeaderboard() {
            try {
                const result = await apiRequest('/api/debug/trigger/event', 'POST', {
                    event: 'show_leaderboard'
                });
                document.getElementById('leaderboard-results').textContent = JSON.stringify(result, null, 2);
                showNotification('Triggered leaderboard display', 'success');
            } catch (error) {
                showNotification('Failed to show leaderboard', 'error');
            }
        }

        async function resetPlayer() {
            const username = document.getElementById('lb-username').value;
            if (!username) {
                showNotification('Username is required', 'error');
                return;
            }

            try {
                const result = await apiRequest('/api/debug/reset/player', 'POST', { name: username });
                document.getElementById('leaderboard-results').textContent = JSON.stringify(result, null, 2);
                showNotification(`Reset stats for ${username}`, 'success');
            } catch (error) {
                showNotification('Failed to reset player', 'error');
            }
        }

        async function clearCache() {
            try {
                const result = await apiRequest('/api/debug/cache/clear', 'POST');
                document.getElementById('leaderboard-results').textContent = JSON.stringify(result, null, 2);
                showNotification('Cache cleared successfully', 'success');
            } catch (error) {
                showNotification('Failed to clear cache', 'error');
            }
        }

        async function getUserStats() {
            const username = document.getElementById('lb-username').value.trim();
            if (!username) {
                showNotification('Please enter a username', 'error');
                return;
            }

            try {
                const result = await apiRequest(`/api/leaderboard/player/${encodeURIComponent(username)}`);
                document.getElementById('leaderboard-results').textContent = JSON.stringify(result, null, 2);
                showNotification(`Retrieved stats for ${username}`, 'success');
            } catch (error) {
                showNotification(`Failed to get stats for ${username}`, 'error');
            }
        }

        // Game Functions
        async function restartGame() {
            if (!confirm('Are you sure you want to restart the game for all players?')) return;

            try {
                const result = await apiRequest('/api/debug/trigger/event', 'POST', { event: 'restart_game' });
                document.getElementById('system-results').textContent = JSON.stringify(result, null, 2);
                showNotification('Game restarted', 'success');
            } catch (error) {
                showNotification('Failed to restart game', 'error');
            }
        }

        // Tier helper function for new rarity system
        function getTierFromWeight(weight) {
            if (weight >= 30) return 'Mil-Spec (72.54%)';
            if (weight >= 15) return 'Restricted (18%)';
            if (weight >= 9) return 'Classified (6.8%)';
            if (weight >= 5) return 'Covert (2.4%)';
            return 'Gold (0.26%)';
        }

        // System Functions
        async function getSystemHealth() {
            try {
                const result = await apiRequest('/health');
                document.getElementById('system-results').textContent = JSON.stringify(result, null, 2);
                showNotification('System health check completed', 'success');
            } catch (error) {
                showNotification('Failed to get system health', 'error');
            }
        }

        async function getDatabaseStats() {
            try {
                const result = await apiRequest('/api/debug/database/stats');
                document.getElementById('system-results').textContent = JSON.stringify(result, null, 2);
                showNotification('Retrieved database stats', 'success');
            } catch (error) {
                showNotification('Failed to get database stats', 'error');
            }
        }

        async function createBackup() {
            if (!confirm('Create a database backup? This may take a moment.')) return;

            try {
                const result = await apiRequest('/api/debug/database/backup', 'POST');
                document.getElementById('system-results').textContent = JSON.stringify(result, null, 2);
                showNotification('Database backup created', 'success');
            } catch (error) {
                showNotification('Failed to create backup', 'error');
            }
        }

        async function getSystemInfo() {
            try {
                const result = await apiRequest('/api/debug/system');
                document.getElementById('system-results').textContent = JSON.stringify(result, null, 2);
                showNotification('Retrieved system information', 'success');
            } catch (error) {
                showNotification('Failed to get system info', 'error');
            }
        }

        // Volume Settings Functions
        async function loadVolumeSettings() {
            try {
                const result = await apiRequest('/api/debug/settings/volume');
                const volume = result.data?.volume ?? 100;
                document.getElementById('volume-slider').value = volume;
                document.getElementById('volume-value').textContent = volume;
                document.getElementById('volume-status').textContent = `Current volume: ${volume}%`;
            } catch (error) {
                console.error('Failed to load volume settings:', error);
            }
        }

        async function saveVolumeSettings() {
            const volume = document.getElementById('volume-slider').value;

            try {
                const result = await apiRequest('/api/debug/settings/volume', 'POST', { volume: Number(volume) });
                document.getElementById('volume-status').textContent = `Volume saved: ${result.data?.volume ?? volume}%`;
                showNotification(`Sound volume set to ${volume}%`, 'success');
            } catch (error) {
                showNotification('Failed to save volume settings', 'error');
            }
        }

        // Level Up Chat Settings Functions
        async function loadLevelUpChatSettings() {
            try {
                const result = await apiRequest('/api/debug/level-up-chat');
                const enabled = result.data?.enabled ?? false;
                document.getElementById('level-up-chat-enabled').checked = enabled;
                document.getElementById('level-up-chat-status').textContent = enabled ? 'Level up messages are enabled' : 'Level up messages are disabled';
            } catch (error) {
                console.error('Failed to load level up chat settings:', error);
            }
        }

        async function saveLevelUpChatSettings() {
            const enabled = document.getElementById('level-up-chat-enabled').checked;

            try {
                const result = await apiRequest('/api/debug/level-up-chat', 'POST', { enabled });
                const savedEnabled = result.data?.enabled ?? enabled;
                document.getElementById('level-up-chat-status').textContent = savedEnabled ? 'Level up messages are enabled' : 'Level up messages are disabled';
                showNotification(`Level up chat messages ${savedEnabled ? 'enabled' : 'disabled'}`, 'success');
            } catch (error) {
                showNotification('Failed to save level up chat settings', 'error');
            }
        }

        // Utility Functions
        function copyToken() {
            if (tokenData) {
                navigator.clipboard.writeText(tokenData.token);
                showNotification('Token copied to clipboard', 'success');
            }
        }



        function copyObsGameUrl() {
            if (tokenData) {
                const url = `${window.location.origin}/?token=${tokenData.token}`;
                navigator.clipboard.writeText(url);
                showNotification('OBS Game URL copied to clipboard', 'success');
            }
        }

        function copyObsLeaderboardUrl() {
            const url = `${window.location.origin}/leaderboard`;
            navigator.clipboard.writeText(url);
            showNotification('OBS Leaderboard URL copied to clipboard', 'success');
        }

        function copyObsUnboxUrl() {
            const url = `${window.location.origin}/unbox`;
            navigator.clipboard.writeText(url);
            showNotification('OBS Unbox URL copied to clipboard', 'success');
        }

        function switchTab(index) {
            // Show warning overlay for setup tab (index 9)
            if (index === 9) {
                document.getElementById('warning-overlay').classList.remove('hidden');
                window.pendingSetupTab = true;
                return;
            }

            // Stop auto-refresh when leaving tokens tab
            if (sessionRefreshInterval) {
                stopAutoRefreshSessions();
            }

            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.add('hidden'));
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            
            // Show selected tab
            document.getElementById(`tab-${index}`).classList.remove('hidden');
            document.querySelectorAll('.tab')[index].classList.add('active');
            
            // Auto-load skins when skins tab is opened (tab-2)
            if (index === 2) {
                loadAllSkins();
                loadSeasonalSkinStatus();
                populateSeasonalSkinSelect();
            }
            
            // Auto-load announcements and follow reward when announcements tab is opened (tab-5)
            if (index === 5) {
                loadAnnouncement();
                loadFollowReward();
            }

            // Auto-load contest when contest tab is opened (tab-6)
            if (index === 6) {
                loadContest();
            }

            // Auto-load volume and chat settings when system tab is opened (tab-7)
            if (index === 7) {
                loadVolumeSettings();
                loadLevelUpChatSettings();
            }

            // Auto-load setup when setup tab is opened (tab-9)
            if (index === 9) {
                loadSetup();
            }

            // Check Twitch connections when tokens tab is opened (tab-0)
            if (index === 0) {
                checkConnectionsOnTokensTab();
            }

            // Load moderators when moderators tab is opened (tab-8)
            if (index === 8) {
                loadModerators();
            }
        }

        async function logout() {
            try {
                const response = await fetch('/auth/logout', {
                    method: 'POST',
                    credentials: 'include'
                });
                
                if (response.ok) {
                    document.getElementById('dashboard').classList.add('hidden');
                    document.getElementById('login-section').classList.remove('hidden');
                    adminToken = '';
                    tokenData = null;
                    
                    // Stop auto-refresh on logout
                    stopAutoRefreshSessions();
                    
                    showAuthMessage('Successfully logged out!', 'success');
                } else {
                    showAuthError('Failed to logout');
                }
            } catch (error) {
                console.error('Logout error:', error);
                showAuthError('Failed to logout');
            }
        }

        function showNotification(message, type) {
            const notification = document.getElementById('notification');
            notification.className = `notification alert alert-${type}`;
            notification.textContent = message;
            notification.classList.remove('hidden');

            setTimeout(() => {
                notification.classList.add('hidden');
            }, 5000);
        }

        // Skin Management Functions
        async function giftSkin() {
            const username = document.getElementById('gift-username').value;
            const skinName = document.getElementById('gift-skin').value;

            if (!username || !skinName) {
                showNotification('Username and skin are required', 'error');
                return;
            }

            try {
                const response = await fetch(`/api/skins/give?name=${username}&skin=${skinName}`, {
                    headers: { 'Authorization': `Bearer ${adminToken}` }
                });
                const result = await response.json();
                document.getElementById('gift-results').textContent = JSON.stringify(result, null, 2);
                showNotification(`Gifted ${skinName} to ${username}`, 'success');
            } catch (error) {
                showNotification('Failed to gift skin', 'error');
            }
        }

        // Seasonal Skin Functions
        async function loadSeasonalSkinStatus() {
            const statusEl = document.getElementById('seasonal-skin-status');
            const selectEl = document.getElementById('seasonal-skin-select');
            try {
                const result = await apiRequest('/api/debug/skins/seasonal');
                if (result.data) {
                    const { seasonalSkin, isActive } = result.data;
                    statusEl.textContent = isActive
                        ? `Currently active: "${seasonalSkin}" - all users have this skin in their inventory`
                        : 'No seasonal skin active';

                    // Set the dropdown to current value
                    if (selectEl && seasonalSkin) {
                        selectEl.value = seasonalSkin;
                    }
                }
            } catch (error) {
                console.error('Failed to load seasonal skin status:', error);
                statusEl.textContent = 'Could not load status';
            }
        }

        async function setSeasonalSkin() {
            const skinName = document.getElementById('seasonal-skin-select').value;

            try {
                const result = await apiRequest('/api/debug/skins/seasonal', 'POST', {
                    skinName: skinName || null
                });

                showNotification(result.message || 'Seasonal skin updated', 'success');
                loadSeasonalSkinStatus();
            } catch (error) {
                showNotification('Failed to set seasonal skin', 'error');
            }
        }

        async function clearSeasonalSkin() {
            if (!confirm('Clear seasonal skin? Users who have it selected will be reset to default.')) {
                return;
            }

            try {
                const result = await apiRequest('/api/debug/skins/seasonal', 'DELETE');

                document.getElementById('seasonal-skin-select').value = '';
                showNotification(result.message || 'Seasonal skin cleared', 'success');
                loadSeasonalSkinStatus();
            } catch (error) {
                showNotification('Failed to clear seasonal skin', 'error');
            }
        }

        let currentSkinData = null;

        async function editSkin(skinName) {
            try {
                // Get current skin data
                const result = await apiRequest('/api/debug/skins/config');
                const skinConfig = result.data.find(s => s.name === skinName);
                
                if (!skinConfig) {
                    showNotification('Skin not found', 'error');
                    return;
                }

                currentSkinData = skinConfig;
                
                // Populate modal
                document.getElementById('editSkinName').value = skinName;
                document.getElementById('editCanUnbox').checked = skinConfig.canUnbox || false;
                document.getElementById('editUnboxWeight').value = skinConfig.unboxWeight || 0;
                
                // Show/hide weight field based on canUnbox
                toggleWeightField();
                
                // Show modal
                document.getElementById('editSkinModal').classList.remove('hidden');
            } catch (error) {
                showNotification('Failed to load skin data', 'error');
            }
        }

        function closeEditSkinModal() {
            document.getElementById('editSkinModal').classList.add('hidden');
            currentSkinData = null;
        }

        // Close modal when clicking outside
        document.addEventListener('click', (e) => {
            const editModal = document.getElementById('editSkinModal');
            const approvalModal = document.getElementById('approvalModal');
            const fullscreenModal = document.getElementById('fullscreenModal');
            
            if (e.target === editModal) {
                closeEditSkinModal();
            }
            if (e.target === approvalModal) {
                closeApprovalModal();
            }
            if (e.target === fullscreenModal) {
                closeFullscreenModal();
            }
        });

        function toggleWeightField() {
            const canUnbox = document.getElementById('editCanUnbox').checked;
            const weightGroup = document.getElementById('unboxWeightGroup');
            weightGroup.style.display = canUnbox ? 'block' : 'none';
        }

        // Add event listener for canUnbox checkbox
        document.getElementById('editCanUnbox').addEventListener('change', toggleWeightField);
        document.getElementById('approvalCanUnbox').addEventListener('change', toggleApprovalWeightField);

        function toggleApprovalWeightField() {
            const canUnbox = document.getElementById('approvalCanUnbox').checked;
            const weightGroup = document.getElementById('approvalWeightGroup');
            weightGroup.style.display = canUnbox ? 'block' : 'none';
        }

        async function saveSkinEdit() {
            if (!currentSkinData) return;

            const newName = document.getElementById('editSkinName').value.trim();
            const canUnbox = document.getElementById('editCanUnbox').checked;
            const unboxWeight = parseInt(document.getElementById('editUnboxWeight').value) || 0;

            if (!newName) {
                showNotification('Please enter a valid skin name', 'error');
                return;
            }

            try {
                // If name changed, rename the skin first
                if (currentSkinData.name !== newName) {
                    try {
                        await apiRequest('/api/debug/skins/rename', 'POST', {
                            oldName: currentSkinData.name,
                            newName: newName
                        });
                    } catch (renameError) {
                        showNotification('Failed to rename skin', 'error');
                        return;
                    }
                }

                // Update skin configuration
                const result = await apiRequest('/api/debug/skins/config/update', 'POST', {
                    name: newName, // Use the new name
                    canUnbox: canUnbox,
                    unboxWeight: canUnbox ? unboxWeight : 0
                });

                showNotification('Skin updated successfully', 'success');
                closeEditSkinModal();
                loadAllSkins(); // Refresh skin list
                
                // Emit refresh events to connected clients
                try {
                    await apiRequest('/api/debug/emit-refresh', 'POST');
                } catch (refreshError) {
                    console.warn('Failed to emit refresh events:', refreshError);
                }
            } catch (error) {
                showNotification('Failed to update skin', 'error');
            }
        }

        async function reloadSkinSystem() {
            if (!confirm('Reload the skin system? This will apply any config changes.')) return;

            try {
                const result = await apiRequest('/api/debug/skins/reload', 'POST');
                showNotification('Skin system reloaded successfully', 'success');
                loadAllSkins(); // Refresh skin list
            } catch (error) {
                showNotification('Failed to reload skin system', 'error');
            }
        }

        // WebSocket connection for real-time updates
        let adminSocket = null;

        function connectAdminSocket() {
            if (adminSocket) {
                adminSocket.disconnect();
            }

            // Connect to the WebSocket server
            adminSocket = io();

            adminSocket.on('connect', () => {
                console.log('Admin panel connected to WebSocket');
            });

            adminSocket.on('disconnect', () => {
                console.log('Admin panel disconnected from WebSocket');
            });

            // Listen for token status updates
            adminSocket.on('tokenStatusUpdate', (data) => {
                console.log('Received token status update:', data);
                if (data.token && data.info !== undefined && data.inUse !== undefined) {
                    const previousInUse = tokenData ? tokenData.inUse : false;
                    const previousBrowser = tokenData?.info?.browserInfo?.name;
                    
                    tokenData = data;
                    updateTokenDisplay();
                    
                    // Show notification if status changed
                    if (tokenData.inUse !== previousInUse) {
                        if (tokenData.inUse) {
                            const browserInfo = tokenData.info?.browserInfo;
                            const browserText = browserInfo ? `${browserInfo.name}${browserInfo.version !== 'Unknown' ? ' ' + browserInfo.version : ''}` : 'Unknown Browser';
                            showNotification(`Token now in use by ${browserText}`, 'success');
                        } else {
                            showNotification('Token is now available', 'success');
                        }
                    } else if (tokenData.inUse && previousBrowser && tokenData.info?.browserInfo?.name !== previousBrowser) {
                        // Browser changed while token was in use
                        const browserInfo = tokenData.info?.browserInfo;
                        const browserText = browserInfo ? `${browserInfo.name}${browserInfo.version !== 'Unknown' ? ' ' + browserInfo.version : ''}` : 'Unknown Browser';
                        showNotification(`Browser changed to ${browserText}`, 'success');
                    }
                }
            });

            // Listen for token regeneration
            adminSocket.on('tokenRegenerated', (data) => {
                console.log('Token regenerated:', data);
                if (data.token) {
                    tokenData.token = data.token;
                    tokenData.inUse = false;
                    updateTokenDisplay();
                    showNotification('Token regenerated successfully', 'success');
                }
            });

            // Simple force refresh event - no bullshit, just reload
            adminSocket.on('forceRefresh', (data) => {
                console.log('üîÑ Force refresh signal received - reloading page immediately');
                console.log('Refresh reason:', data.message);
                location.reload();
            });
        }

        // Fallback polling every 30 seconds (much less frequent since we have WebSocket)
        setInterval(() => {
            if (adminToken && !document.getElementById('dashboard').classList.contains('hidden')) {
                loadTokenData();
            }
        }, 30000);

        // Enter key support for login
        document.getElementById('password').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') authenticate();
        });

        // Theme Management
        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            
            // Update toggle button
            const themeIcon = document.getElementById('theme-icon');
            const themeText = document.getElementById('theme-text');
            
            if (newTheme === 'dark') {
                themeIcon.textContent = '‚òÄÔ∏è';
                themeText.textContent = 'Light';
            } else {
                themeIcon.textContent = 'üåô';
                themeText.textContent = 'Dark';
            }
        }

        // Initialize theme on page load
        function initTheme() {
            const savedTheme = localStorage.getItem('theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            const theme = savedTheme || (prefersDark ? 'dark' : 'light');
            
            document.documentElement.setAttribute('data-theme', theme);
            
            // Update toggle button
            const themeIcon = document.getElementById('theme-icon');
            const themeText = document.getElementById('theme-text');
            
            if (theme === 'dark') {
                themeIcon.textContent = '‚òÄÔ∏è';
                themeText.textContent = 'Light';
            } else {
                themeIcon.textContent = 'üåô';
                themeText.textContent = 'Dark';
            }
        }

        // Initialize page when loaded
        function initPage() {
            console.log('Initializing admin panel...');
            
            // Check for saved admin token
            const savedToken = localStorage.getItem('adminToken');
            if (savedToken) {
                console.log('Found saved admin token, loading dashboard...');
                adminToken = savedToken;
                document.getElementById('login-section').classList.add('hidden');
                document.getElementById('dashboard').classList.remove('hidden');
                
                // Connect WebSocket for real-time updates
                connectAdminSocket();
                
                // Load initial data and update URLs after data is loaded
                loadTokenData().then(() => {
                    console.log('Token data loaded, updating URLs...');
                    updateStaticUrls(); // Update URLs after token data is loaded
                    
                    // Start auto-refresh for tokens tab if it's the default tab
                    const tokensTab = document.getElementById('tab-0');
                    if (tokensTab && !tokensTab.classList.contains('hidden')) {
                        checkConnectionsOnTokensTab(); // This will start auto-refresh
                    }
                }).catch(error => {
                    console.error('Failed to load token data:', error);
                    updateStaticUrls(); // Update URLs even if token data fails
                });
            } else {
                console.log('No saved token, updating static URLs only');
                // If no token, just update static URLs without token info
                updateStaticUrls();
            }
        }

        // Initialize static URLs immediately
        updateStaticUrls();

        // Check Twitch connection status
        async function checkTwitchConnections() {
            try {
                const response = await fetch('/api/setup', {
                    headers: { 'Authorization': `Bearer ${adminToken}` }
                });
                
                if (response.ok) {
                    const config = await response.json();
                    updateTwitchConnectionStatus(config);
                } else {
                    updateTwitchConnectionStatus({});
                }
            } catch (error) {
                console.error('Error checking Twitch connections:', error);
                updateTwitchConnectionStatus({});
            }
        }

        function updateTwitchConnectionStatus(config) {
            const streamerElement = document.getElementById('streamer-connection');
            const streamerStatus = document.getElementById('streamer-status');
            const botElement = document.getElementById('bot-connection');
            const botStatus = document.getElementById('bot-status');

            // Check streamer connection
            if (config.STREAMER_ACCESS_TOKEN && config.TWITCH_CHANNEL) {
                streamerElement.className = 'connection-item connection-success';
                streamerStatus.textContent = `Connected as ${config.TWITCH_CHANNEL}`;
            } else {
                streamerElement.className = 'connection-item connection-error';
                streamerStatus.textContent = 'Not connected';
            }

            // Check bot connection
            if (config.BOT_ACCESS_TOKEN && config.BOT_NAME) {
                botElement.className = 'connection-item connection-success';
                botStatus.textContent = `Connected as ${config.BOT_NAME}`;
            } else {
                botElement.className = 'connection-item connection-error';
                botStatus.textContent = 'Not connected';
            }
        }

        // Check connections when switching to tokens tab
        function checkConnectionsOnTokensTab() {
            if (adminToken) {
                checkTwitchConnections();
                refreshConnectedBrowsers(); // Also refresh connected browsers
                startAutoRefreshSessions(); // Start auto-refresh for this tab
                
                // Force an immediate refresh after a short delay to ensure data loads
                setTimeout(() => {
                    refreshConnectedBrowsers();
                }, 500);
            }
        }

        // Auto-refresh sessions management
        function startAutoRefreshSessions() {
            // Clear any existing interval
            if (sessionRefreshInterval) {
                clearInterval(sessionRefreshInterval);
            }
            
            // Refresh every 5 seconds when on tokens tab (less frequent to avoid UI issues)
            sessionRefreshInterval = setInterval(() => {
                // Only refresh if we're on the tokens tab (tab-0)
                const tokensTab = document.getElementById('tab-0');
                if (tokensTab && !tokensTab.classList.contains('hidden')) {
                    refreshConnectedBrowsers();
                }
            }, 5000);
        }

        function stopAutoRefreshSessions() {
            if (sessionRefreshInterval) {
                clearInterval(sessionRefreshInterval);
                sessionRefreshInterval = null;
            }
        }

        // Setup Tab Functions
        function acknowledgeWarning() {
            document.getElementById('warning-overlay').classList.add('hidden');
            if (window.pendingSetupTab) {
                window.pendingSetupTab = false;
                // Actually switch to setup tab
                document.querySelectorAll('.tab-content').forEach(tab => tab.classList.add('hidden'));
                document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
                document.getElementById('tab-9').classList.remove('hidden');
                document.querySelectorAll('.tab')[9].classList.add('active');
                loadSetup();
            }
        }

        function goBackFromSetup() {
            document.getElementById('warning-overlay').classList.add('hidden');
            window.pendingSetupTab = false;
            // Go back to tokens tab
            switchTab(0);
        }

        async function loadSetup() {
            try {
                const response = await fetch('/api/setup', {
                    headers: { 'Authorization': `Bearer ${adminToken}` }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    populateSetupFields(data);
                    document.getElementById('setup-results').textContent = 'Configuration loaded successfully';
                } else {
                    document.getElementById('setup-results').textContent = 'No configuration found or error loading';
                }
            } catch (error) {
                document.getElementById('setup-results').textContent = 'Error loading configuration: ' + error.message;
            }
        }

        function populateSetupFields(data) {
            document.getElementById('twitch-client').value = data.TWITCH_CLIENT || '';
            document.getElementById('twitch-channel').value = data.TWITCH_CHANNEL || '';
            document.getElementById('bot-name').value = data.BOT_NAME || '';
            document.getElementById('twitch-user-id').value = data.TWITCH_USER_ID || '';
            document.getElementById('streamer-access-token').value = data.STREAMER_ACCESS_TOKEN || '';
            document.getElementById('bot-access-token').value = data.BOT_ACCESS_TOKEN || '';
            document.getElementById('twitch-duel-reward').value = data.TWITCH_DUEL_REWARD || '';
            document.getElementById('twitch-cone-reward').value = data.TWITCH_CONE_REWARD || '';
            document.getElementById('twitch-unbox-cone').value = data.TWITCH_UNBOX_CONE || '';
            document.getElementById('twitch-buy-cone').value = data.TWITCH_BUY_CONE || '';
            document.getElementById('seventv-token').value = data.SEVENTV_TOKEN || '';
        }

        function getSetupData() {
            return {
                TWITCH_CLIENT: document.getElementById('twitch-client').value,
                TWITCH_CHANNEL: document.getElementById('twitch-channel').value,
                BOT_NAME: document.getElementById('bot-name').value,
                TWITCH_USER_ID: document.getElementById('twitch-user-id').value,
                STREAMER_ACCESS_TOKEN: document.getElementById('streamer-access-token').value,
                BOT_ACCESS_TOKEN: document.getElementById('bot-access-token').value,
                TWITCH_DUEL_REWARD: document.getElementById('twitch-duel-reward').value,
                TWITCH_CONE_REWARD: document.getElementById('twitch-cone-reward').value,
                TWITCH_UNBOX_CONE: document.getElementById('twitch-unbox-cone').value,
                TWITCH_BUY_CONE: document.getElementById('twitch-buy-cone').value,
                SEVENTV_TOKEN: document.getElementById('seventv-token').value
            };
        }

        async function saveSetup() {
            const setupData = getSetupData();
            
            try {
                const response = await fetch('/api/setup', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${adminToken}`
                    },
                    body: JSON.stringify(setupData)
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    document.getElementById('setup-results').textContent = 'Configuration saved successfully!';
                    showNotification('Configuration saved to setup.json', 'success');
                } else {
                    document.getElementById('setup-results').textContent = 'Error saving: ' + result.message;
                    showNotification('Failed to save configuration', 'error');
                }
            } catch (error) {
                document.getElementById('setup-results').textContent = 'Error saving configuration: ' + error.message;
                showNotification('Error saving configuration', 'error');
            }
        }

        async function testConfiguration() {
            const setupData = getSetupData();
            
            try {
                const response = await fetch('/api/setup/test', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${adminToken}`
                    },
                    body: JSON.stringify(setupData)
                });
                
                const result = await response.json();
                document.getElementById('setup-results').textContent = JSON.stringify(result, null, 2);
                
                if (response.ok) {
                    showNotification('Configuration test completed', 'success');
                } else {
                    showNotification('Configuration test failed', 'error');
                }
            } catch (error) {
                document.getElementById('setup-results').textContent = 'Error testing configuration: ' + error.message;
                showNotification('Error testing configuration', 'error');
            }
        }

        function openTwitchTokenGenerator() {
            const tokenGeneratorUrl = 'https://twitchtokengenerator.com/';
            window.open(tokenGeneratorUrl, '_blank');
            showNotification('Opened Twitch Token Generator in new tab', 'success');
        }

        // --- AUTO-LOGIN WITH PASSWORD (plain text) ---
        function saveAdminPassword(pass) {
            if (pass) {
                localStorage.setItem('adminPassword', pass);
            }
        }
        function getSavedAdminPassword() {
            return localStorage.getItem('adminPassword') || '';
        }
        function clearSavedAdminPassword() {
            localStorage.removeItem('adminPassword');
        }

        // On page load, auto-fill and auto-login if password is saved
        window.addEventListener('load', () => {
            const savedPass = localStorage.getItem('adminPassword');
            if (savedPass) {
                document.getElementById('password').value = savedPass;
                authenticate();
            }
        });

        // Additional URL initialization on DOMContentLoaded (backup)
        window.addEventListener('DOMContentLoaded', function() {
            var leaderboardUrl = document.getElementById('obs-leaderboard-url');
            if (leaderboardUrl) leaderboardUrl.textContent = window.location.origin + '/leaderboard';
            var unboxUrl = document.getElementById('obs-unbox-url');
            if (unboxUrl) unboxUrl.textContent = window.location.origin + '/unbox';
        });

        // Fullscreen modal functions
        function openFullscreenModal(imageSrc, imageName) {
            const modal = document.getElementById('fullscreenModal');
            const image = document.getElementById('fullscreenImage');
            
            image.src = imageSrc;
            image.alt = `Fullscreen preview of ${imageName}`;
            
            modal.classList.remove('hidden');
            
            // Prevent body scroll when modal is open
            document.body.style.overflow = 'hidden';
        }

        function closeFullscreenModal() {
            const modal = document.getElementById('fullscreenModal');
            modal.classList.add('hidden');

            // Restore body scroll
            document.body.style.overflow = '';
        }

        // ===== NUCLEAR RESET FUNCTIONS =====
        var nukeAudio = null;

        function openNukeModal() {
            const modal = document.getElementById('nukeModal');
            modal.classList.remove('hidden');
            document.body.style.overflow = 'hidden';

            // Reset to step 1
            nukeStep(1);

            // Try to get streamer name from the setup
            const streamerCallout = document.getElementById('streamer-callout');
            const channelInput = document.getElementById('twitch-channel');
            if (channelInput && channelInput.value) {
                streamerCallout.textContent = channelInput.value.toUpperCase();
            } else {
                // Try to get it from the connection status
                const streamerStatus = document.getElementById('streamer-status');
                if (streamerStatus && streamerStatus.textContent.includes('Connected as')) {
                    const name = streamerStatus.textContent.replace('Connected as ', '');
                    streamerCallout.textContent = name.toUpperCase();
                } else {
                    streamerCallout.textContent = 'DEAR STREAMER';
                }
            }
        }

        function closeNukeModal() {
            const modal = document.getElementById('nukeModal');
            modal.classList.add('hidden');
            document.body.style.overflow = '';

            // Reset to step 1 for next time
            nukeStep(1);
        }

        function nukeStep(step) {
            // Hide all steps
            document.querySelectorAll('.nuke-step').forEach(el => {
                el.classList.remove('active');
            });

            // Show the target step
            const targetStep = document.getElementById(`nuke-step-${step}`);
            if (targetStep) {
                targetStep.classList.add('active');
            }
        }

        async function launchNuke() {
            // Close the modal
            closeNukeModal();

            // Show the countdown overlay
            const overlay = document.getElementById('nukeOverlay');
            const countdownEl = document.getElementById('nukeCountdown');
            const explosion = document.getElementById('nukeExplosion');

            overlay.classList.add('active');

            // Play the nuke sound (14 seconds total, detonation at 10 seconds)
            try {
                nukeAudio = new Audio('/nuke.mp3');
                nukeAudio.volume = 0.7;
                nukeAudio.play().then(() => {
                    console.log('Nuke audio playing!');
                }).catch((error) => {
                    console.error('Nuke audio failed to play:', error);
                });
            } catch (e) {
                console.error('Nuke audio error:', e);
            }

            // Countdown from 10 to 1 (detonation at 10 seconds to sync with audio)
            let count = 10;
            countdownEl.textContent = count;

            const countdownInterval = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownEl.textContent = count;
                } else {
                    clearInterval(countdownInterval);

                    // Hide countdown, show explosion
                    overlay.classList.remove('active');
                    explosion.classList.add('active');

                    // Actually perform the reset
                    performNukeReset();

                    // Hide explosion after animation (let audio keep playing for explosion sound)
                    setTimeout(() => {
                        explosion.classList.remove('active');
                    }, 2000);

                    // Stop audio after it finishes (4 more seconds for explosion sound)
                    setTimeout(() => {
                        if (nukeAudio) {
                            nukeAudio.pause();
                            nukeAudio = null;
                        }
                    }, 4500);
                }
            }, 1000);
        }

        async function performNukeReset() {
            try {
                const response = await fetch('/api/debug/reset/all-players', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${adminToken}`,
                        'Content-Type': 'application/json'
                    }
                });

                const result = await response.json();

                if (result.status === 'success') {
                    // Wait for explosion animation to finish
                    setTimeout(() => {
                        showNotification(`TACTICAL NUKE SUCCESSFUL! ${result.data.playersAffected} players have been reset to 0.`, 'success');
                    }, 2200);
                } else {
                    setTimeout(() => {
                        showNotification('Nuke failed to launch: ' + result.message, 'error');
                    }, 2200);
                }
            } catch (error) {
                setTimeout(() => {
                    showNotification('Nuke launch failed: ' + error.message, 'error');
                }, 2200);
            }
        }

        // Close nuke modal with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const nukeModal = document.getElementById('nukeModal');
                if (!nukeModal.classList.contains('hidden')) {
                    closeNukeModal();
                }
            }
        });
        // ===== END NUCLEAR RESET FUNCTIONS =====

        // Close fullscreen modal with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const fullscreenModal = document.getElementById('fullscreenModal');
                if (!fullscreenModal.classList.contains('hidden')) {
                    closeFullscreenModal();
                }
            }
        });

        // Connected Browsers Functions
        async function refreshConnectedBrowsers(showNotifications = false) {
            try {
                const response = await fetch('/api/debug/sessions/active', {
                    headers: { 'Authorization': `Bearer ${adminToken}` }
                });
                const data = await response.json();
                
                if (data.status === 'success' && data.data.activeSessions) {
                    displayConnectedBrowsers(data.data.activeSessions);
                } else {
                    displayConnectedBrowsers([]);
                }
                
                if (showNotifications) {
                    showNotification('Sessions refreshed', 'success');
                }
            } catch (error) {
                console.error('Failed to fetch active sessions:', error);
                displayConnectedBrowsers([]);
                if (showNotifications) {
                    showNotification('Failed to refresh sessions', 'error');
                }
            }
        }

        function displayConnectedBrowsers(sessions) {
            const container = document.getElementById('connected-browsers');
            
            if (!sessions || sessions.length === 0) {
                container.innerHTML = '<div class="no-sessions">No active sessions</div>';
                return;
            }

            // Group sessions by IP to identify multiple sessions from same IP
            const sessionsByIp = sessions.reduce((acc, session) => {
                const ip = session.ip || 'unknown';
                if (!acc[ip]) acc[ip] = [];
                acc[ip].push(session);
                return acc;
            }, {});

            let html = '';
            sessions.forEach(session => {
                const isMultiple = sessionsByIp[session.ip]?.length > 1;
                const browserInfo = session.browserInfo || { name: 'Unknown', type: 'Browser' };
                const browserText = browserInfo.name !== 'Unknown' 
                    ? `${browserInfo.name}${browserInfo.version !== 'Unknown' ? ' ' + browserInfo.version : ''}`
                    : 'Unknown Browser';

                html += `
                    <div class="session-item ${isMultiple ? 'multiple-warning' : ''}">
                        <div class="session-info">
                            <div class="session-browser">${browserText}</div>
                            <div class="session-details">
                                Socket: ${session.socketId}
                                ${session.tokenBound ? ' | Token: ' + session.tokenBound.slice(0, 8) + '...' : ''}
                            </div>
                        </div>
                        <div class="session-actions">
                            ${isMultiple ? '<span class="warning-badge">‚ö†Ô∏è Multiple</span>' : ''}
                            <button class="disconnect-btn" onclick="disconnectSession('${session.socketId}')">
                                Disconnect
                            </button>
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        async function disconnectSession(socketId) {
            if (!confirm('Are you sure you want to disconnect this session?')) return;

            try {
                const response = await fetch('/api/debug/sessions/disconnect', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${adminToken}`
                    },
                    body: JSON.stringify({ socketId })
                });

                const result = await response.json();
                
                if (response.ok) {
                    showNotification('Session disconnected successfully', 'success');
                    
                    // Refresh immediately, then again after a short delay to ensure socket cleanup
                    refreshConnectedBrowsers(false);
                    setTimeout(() => {
                        refreshConnectedBrowsers(false);
                    }, 1000);
                } else {
                    showNotification(result.message || 'Failed to disconnect session', 'error');
                }
            } catch (error) {
                console.error('Failed to disconnect session:', error);
                showNotification('Failed to disconnect session', 'error');
            }
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            stopAutoRefreshSessions();
        });

        // Announcement Management Functions
        async function loadAnnouncement() {
            try {
                const response = await fetch('/api/debug/announcement', {
                    headers: { 'Authorization': `Bearer ${adminToken}` }
                });
                const result = await response.json();
                
                if (response.ok && result.data) {
                    const announcement = result.data;
                    document.getElementById('announcement-enabled').checked = announcement.enabled || false;
                    document.getElementById('announcement-content').value = announcement.content || '';
                    
                    updateAnnouncementPreview();
                    
                    document.getElementById('announcement-results').textContent = JSON.stringify(announcement, null, 2);
                } else {
                    document.getElementById('announcement-results').textContent = 'No announcement data found';
                }
            } catch (error) {
                console.error('Error loading announcement:', error);
                document.getElementById('announcement-results').textContent = 'Error loading announcement: ' + error.message;
            }
        }

        async function saveAnnouncement() {
            const enabled = document.getElementById('announcement-enabled').checked;
            const content = document.getElementById('announcement-content').value;
            
            try {
                const response = await fetch('/api/debug/announcement', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${adminToken}`
                    },
                    body: JSON.stringify({ enabled, content })
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    document.getElementById('announcement-results').textContent = JSON.stringify(result.data, null, 2);
                    updateAnnouncementPreview();
                    showNotification('Announcement saved successfully', 'success');
                } else {
                    document.getElementById('announcement-results').textContent = 'Error: ' + result.message;
                    showNotification('Failed to save announcement', 'error');
                }
            } catch (error) {
                console.error('Error saving announcement:', error);
                document.getElementById('announcement-results').textContent = 'Error saving announcement: ' + error.message;
                showNotification('Error saving announcement', 'error');
            }
        }

        function previewAnnouncement() {
            updateAnnouncementPreview();
        }

        function updateAnnouncementPreview() {
            const enabled = document.getElementById('announcement-enabled').checked;
            const content = document.getElementById('announcement-content').value;
            const preview = document.getElementById('announcement-preview');
            const noMessage = document.getElementById('no-announcement-message');
            
            if (enabled && content.trim()) {
                preview.innerHTML = content;
                preview.style.display = 'block';
                noMessage.style.display = 'none';
            } else {
                preview.style.display = 'none';
                noMessage.style.display = 'block';
            }
        }

        // Load announcement data when switching to announcements tab
        function loadAnnouncementTab() {
            loadAnnouncement();
        }

        // Trail Management Functions
        async function loadAllTrails() {
            try {
                const [configResponse, usersResponse] = await Promise.all([
                    fetch('/api/trails/config'),
                    fetch('/api/trails/users')
                ]);
                
                const trailConfigs = await configResponse.json();
                const userTrails = await usersResponse.json();
                
                const container = document.getElementById('trails-container');
                const giftSelect = document.getElementById('trail-gift-select');
                
                if (trailConfigs && trailConfigs.length > 0) {
                    // Populate trail management list
                    container.innerHTML = trailConfigs.map(trail => {
                        const usersWithTrail = userTrails.data ? userTrails.data.filter(u => u.trail === trail.name).length : 0;
                        
                        return `
                            <div class="trail-item">
                                <div class="trail-info">
                                    <div class="trail-preview ${trail.name}" style="background: ${getTrailPreviewColor(trail.name)}">‚ú®</div>
                                    <div class="trail-details">
                                        <h4>${formatTrailName(trail.name)}</h4>
                                        <p>Type: ${trail.type || 'particle'}</p>
                                        <p>Tier: ${trail.tier || 'unknown'}</p>
                                        <p>Available: Yes</p>
                                        <p>Users with trail: ${usersWithTrail}</p>
                                        ${trail.author ? `<p>Author: ${trail.author}</p>` : ''}
                                    </div>
                                </div>
                                <div class="trail-actions">
                                    <button class="btn btn-small btn-info" onclick="viewTrailDetails('${trail.name}')">
                                        View Config
                                    </button>
                                    <button class="btn btn-small btn-success" onclick="previewTrail('${trail.name}')">
                                        Preview
                                    </button>
                                </div>
                            </div>
                        `;
                    }).join('');

                    // Populate gift select
                    giftSelect.innerHTML = '<option value="">Select a trail...</option>' + 
                        trailConfigs.map(trail => `<option value="${trail.name}">${formatTrailName(trail.name)}</option>`).join('');
                } else {
                    container.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 20px;">No trails configured</div>';
                }
                
                showNotification('Trails loaded successfully', 'success');
            } catch (error) {
                console.error('Error loading trails:', error);
                const container = document.getElementById('trails-container');
                container.innerHTML = '<div style="text-align: center; color: #ef4444; padding: 20px;">Error loading trails</div>';
                showNotification('Failed to load trails', 'error');
            }
        }

        function getTrailPreviewColor(trailName) {
            const colorMap = {
                'default': 'linear-gradient(45deg, #6b7280, #9ca3af)',
                'sparkle': 'linear-gradient(45deg, #ffd700, #ffed4e)',
                'fire': 'linear-gradient(45deg, #ff4500, #ff6347, #ffd700)',
                'ice': 'linear-gradient(45deg, #87ceeb, #b0e0e6, #ffffff)',
                'rainbow': 'linear-gradient(45deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3)',
                'electric': 'linear-gradient(45deg, #00ffff, #0080ff, #ffffff)',
                'cosmic': 'linear-gradient(45deg, #800080, #4b0082, #9400d3, #ff1493)',
                'shadow': 'linear-gradient(45deg, #2f2f2f, #1c1c1c, #000000)',
                'golden': 'linear-gradient(45deg, #ffd700, #ffa500, #ffff00)'
            };
            return colorMap[trailName] || 'linear-gradient(45deg, #8b5cf6, #06b6d4)';
        }

        function formatTrailName(trailName) {
            if (!trailName) return 'Unknown';
            return trailName.split(/[_-]/).map(word => 
                word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
            ).join(' ');
        }

        async function giveTrailToUser() {
            const username = document.getElementById('trail-gift-username').value.trim();
            const trailName = document.getElementById('trail-gift-select').value;
            
            if (!username) {
                showNotification('Please enter a username', 'error');
                return;
            }
            
            if (!trailName) {
                showNotification('Please select a trail', 'error');
                return;
            }
            
            try {
                const response = await fetch(`/api/trails/give?name=${encodeURIComponent(username)}&skin=${encodeURIComponent(trailName)}`, {
                    headers: { 'Authorization': `Bearer ${adminToken}` }
                });
                
                const result = await response.json();
                
                if (response.ok && result.status === 'success') {
                    showNotification(`Gave ${trailName} trail to ${username}`, 'success');
                    document.getElementById('trail-gift-username').value = '';
                    document.getElementById('trail-gift-select').value = '';
                    loadAllTrails(); // Refresh the list
                } else {
                    showNotification(result.message || 'Failed to give trail', 'error');
                }
            } catch (error) {
                console.error('Error giving trail:', error);
                showNotification('Error giving trail', 'error');
            }
        }

        async function viewTrailDetails(trailName) {
            try {
                const response = await fetch('/api/trails/config');
                const trailConfigs = await response.json();
                const trail = trailConfigs.find(t => t.name === trailName);
                
                if (trail) {
                    alert(`Trail Configuration for "${formatTrailName(trailName)}":\n\n${JSON.stringify(trail, null, 2)}`);
                } else {
                    showNotification('Trail configuration not found', 'error');
                }
            } catch (error) {
                console.error('Error viewing trail details:', error);
                showNotification('Error loading trail details', 'error');
            }
        }

        function previewTrail(trailName) {
            showNotification(`Trail preview feature coming soon for ${formatTrailName(trailName)}`, 'info');
        }

        async function reloadTrailSystem() {
            try {
                // Reload trail configurations
                await loadAllTrails();
                showNotification('Trail system reloaded', 'success');
            } catch (error) {
                console.error('Error reloading trail system:', error);
                showNotification('Failed to reload trail system', 'error');
            }
        }

        // Update announcement preview when content changes
        document.addEventListener('DOMContentLoaded', () => {
            const contentTextarea = document.getElementById('announcement-content');
            const enabledCheckbox = document.getElementById('announcement-enabled');
            
            if (contentTextarea) {
                contentTextarea.addEventListener('input', updateAnnouncementPreview);
            }
            if (enabledCheckbox) {
                enabledCheckbox.addEventListener('change', updateAnnouncementPreview);
            }
        });

        // Contest Management Functions
        async function loadContest() {
            try {
                const response = await fetch('/api/debug/contest', {
                    headers: { 'Authorization': `Bearer ${adminToken}` }
                });
                const result = await response.json();
                
                if (response.ok && result.data) {
                    const contest = result.data;
                    document.getElementById('contest-enabled').checked = contest.enabled || false;
                    document.getElementById('contest-submissions').checked = contest.allowSubmissions || false;
                    document.getElementById('contest-prize').value = contest.prize || '';
                    document.getElementById('contest-description').value = contest.description || '';
                    
                    document.getElementById('contest-results').textContent = JSON.stringify(contest, null, 2);
                } else {
                    document.getElementById('contest-results').textContent = 'No contest data found';
                }
            } catch (error) {
                console.error('Error loading contest:', error);
                document.getElementById('contest-results').textContent = 'Error loading contest: ' + error.message;
            }
        }

        async function saveContest() {
            const enabled = document.getElementById('contest-enabled').checked;
            const allowSubmissions = document.getElementById('contest-submissions').checked;
            const prize = document.getElementById('contest-prize').value;
            const description = document.getElementById('contest-description').value;
            
            try {
                const response = await fetch('/api/debug/contest', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${adminToken}`
                    },
                    body: JSON.stringify({ enabled, allowSubmissions, prize, description })
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    document.getElementById('contest-results').textContent = JSON.stringify(result.data, null, 2);
                    showNotification('Contest settings saved successfully', 'success');
                } else {
                    document.getElementById('contest-results').textContent = 'Error: ' + result.message;
                    showNotification('Failed to save contest settings', 'error');
                }
            } catch (error) {
                console.error('Error saving contest:', error);
                document.getElementById('contest-results').textContent = 'Error saving contest: ' + error.message;
                showNotification('Error saving contest settings', 'error');
            }
        }

        // Follow Reward Management Functions
        async function loadFollowReward() {
            try {
                const response = await fetch('/api/debug/follow-reward', {
                    headers: { 'Authorization': `Bearer ${adminToken}` }
                });
                const result = await response.json();

                if (response.ok && result.data) {
                    const settings = result.data;
                    document.getElementById('follow-reward-enabled').checked = settings.enabled || false;
                    document.getElementById('follow-reward-chat-enabled').checked = settings.chatEnabled !== false;
                    document.getElementById('follow-reward-message').value = settings.message || '@{user} thanks for following! Enjoy a free coneflip!';

                    document.getElementById('follow-reward-results').textContent = JSON.stringify(settings, null, 2);
                } else {
                    document.getElementById('follow-reward-results').textContent = 'No follow reward data found';
                }
            } catch (error) {
                console.error('Error loading follow reward:', error);
                document.getElementById('follow-reward-results').textContent = 'Error loading follow reward: ' + error.message;
            }
        }

        async function saveFollowReward() {
            const enabled = document.getElementById('follow-reward-enabled').checked;
            const chatEnabled = document.getElementById('follow-reward-chat-enabled').checked;
            const message = document.getElementById('follow-reward-message').value;

            try {
                const response = await fetch('/api/debug/follow-reward', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${adminToken}`
                    },
                    body: JSON.stringify({ enabled, chatEnabled, message })
                });

                const result = await response.json();

                if (response.ok) {
                    document.getElementById('follow-reward-results').textContent = JSON.stringify(result.data, null, 2);
                    showNotification('Follow reward settings saved successfully', 'success');
                } else {
                    document.getElementById('follow-reward-results').textContent = 'Error: ' + result.message;
                    showNotification('Failed to save follow reward settings', 'error');
                }
            } catch (error) {
                console.error('Error saving follow reward:', error);
                document.getElementById('follow-reward-results').textContent = 'Error saving follow reward: ' + error.message;
                showNotification('Error saving follow reward settings', 'error');
            }
        }

        async function loadContestEntries() {
            try {
                const response = await fetch('/api/debug/skins/submissions', {
                    headers: { 'Authorization': `Bearer ${adminToken}` }
                });
                const result = await response.json();
                
                if (response.ok && result.data) {
                    const contestEntries = result.data.filter(submission => submission.contest === true);
                    displayContestEntries(contestEntries);
                } else {
                    document.getElementById('contest-entries-container').innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 20px;">No contest entries found</div>';
                }
            } catch (error) {
                console.error('Error loading contest entries:', error);
                document.getElementById('contest-entries-container').innerHTML = '<div style="text-align: center; color: #ef4444; padding: 20px;">Error loading contest entries</div>';
            }
        }

        function displayContestEntries(entries) {
            const container = document.getElementById('contest-entries-container');
            
            if (entries.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 20px;">No contest entries submitted yet</div>';
                return;
            }
            
            let html = `<h4>Contest Entries (${entries.length}):</h4><div style="display: grid; gap: 15px; margin-top: 15px;">`;
            
            entries.forEach(entry => {
                const statusColor = entry.status === 'approved' ? '#10b981' : 
                                   entry.status === 'rejected' ? '#ef4444' : '#f59e0b';
                
                html += `
                    <div style="border: 1px solid var(--card-border); border-radius: 8px; padding: 15px; background: var(--card-bg);">
                        <div style="display: flex; align-items: center; gap: 15px;">
                            <img src="/api/skins/submissions/preview/${entry.id}" style="width: 60px; height: 60px; border-radius: 6px; object-fit: cover;" onerror="this.style.display='none'">
                            <div style="flex: 1;">
                                <h5 style="margin: 0 0 5px 0; color: var(--text-primary);">${entry.name}</h5>
                                <p style="margin: 0; color: var(--text-secondary); font-size: 0.9rem;">By: ${entry.author}</p>
                                <p style="margin: 5px 0 0 0; color: ${statusColor}; font-weight: 500; text-transform: uppercase; font-size: 0.8rem;">${entry.status}</p>
                                <p style="margin: 5px 0 0 0; color: var(--text-tertiary); font-size: 0.8rem;">Submitted: ${new Date(entry.uploadedAt).toLocaleDateString()}</p>
                            </div>
                            <div style="display: flex; flex-direction: column; gap: 8px;">
                                <button class="btn btn-danger" onclick="removeFromContest('${entry.id}')" style="background: linear-gradient(135deg, #ef4444, #dc2626); padding: 6px 12px; font-size: 0.8rem;">
                                    Remove from Contest
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            container.innerHTML = html;
        }

        async function removeFromContest(submissionId) {
            if (!confirm('Are you sure you want to remove this submission from the contest? This action cannot be undone.')) {
                return;
            }
            
            try {
                const response = await fetch('/api/debug/contest/remove', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${adminToken}`
                    },
                    body: JSON.stringify({ submissionId })
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    showNotification('Submission removed from contest successfully', 'success');
                    loadContestEntries(); // Reload entries
                } else {
                    showNotification(result.message || 'Failed to remove submission from contest', 'error');
                }
            } catch (error) {
                console.error('Error removing submission from contest:', error);
                showNotification('Error removing submission from contest', 'error');
            }
        }

        async function resetContestDatabase() {
            if (!confirm('‚ö†Ô∏è WARNING: This will permanently delete ALL contest votes and reset the contest database. This action cannot be undone. Are you absolutely sure?')) {
                return;
            }
            
            if (!confirm('üö® FINAL WARNING: This will delete all contest voting data permanently. Type "RESET" in the next prompt to confirm.')) {
                return;
            }
            
            const confirmation = prompt('Type "RESET" to confirm database reset:');
            if (confirmation !== 'RESET') {
                showNotification('Contest database reset cancelled', 'warning');
                return;
            }
            
            try {
                const response = await fetch('/api/debug/contest/reset', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${adminToken}`
                    }
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    showNotification('Contest database reset successfully', 'success');
                    loadContestEntries(); // Reload entries
                } else {
                    showNotification(result.message || 'Failed to reset contest database', 'error');
                }
            } catch (error) {
                console.error('Error resetting contest database:', error);
                showNotification('Error resetting contest database', 'error');
            }
        }

        // Moderator Management Functions
        async function loadModerators() {
            try {
                const response = await fetch('/api/setup', {
                    headers: { 'Authorization': `Bearer ${adminToken}` }
                });

                if (response.ok) {
                    const data = await response.json();
                    const moderators = (data.MODERATORS || '').split(',').map(m => m.trim().toLowerCase()).filter(Boolean);
                    displayModerators(moderators);
                } else {
                    document.getElementById('moderators-list').innerHTML = '<p style="color: var(--text-secondary);">Failed to load moderators</p>';
                }
            } catch (error) {
                console.error('Error loading moderators:', error);
                document.getElementById('moderators-list').innerHTML = '<p style="color: var(--text-secondary);">Error loading moderators</p>';
            }
        }

        function displayModerators(moderators) {
            const container = document.getElementById('moderators-list');

            if (moderators.length === 0) {
                container.innerHTML = '<p style="color: var(--text-secondary);">No moderators configured</p>';
                return;
            }

            container.innerHTML = moderators.map(mod => `
                <div style="display: flex; align-items: center; justify-content: space-between; padding: 10px; background: var(--card-bg); border-radius: 8px; margin-bottom: 8px;">
                    <span style="font-weight: 500;">${mod}</span>
                    <button class="btn btn-danger btn-small" onclick="removeModerator('${mod}')">Remove</button>
                </div>
            `).join('');
        }

        async function addModerator() {
            const input = document.getElementById('new-moderator');
            const username = input.value.trim().toLowerCase();

            if (!username) {
                showNotification('Please enter a username', 'error');
                return;
            }

            if (!/^[a-z0-9_]+$/.test(username)) {
                showNotification('Invalid username format', 'error');
                return;
            }

            try {
                // Get current config
                const response = await fetch('/api/setup', {
                    headers: { 'Authorization': `Bearer ${adminToken}` }
                });

                if (!response.ok) {
                    showNotification('Failed to load current config', 'error');
                    return;
                }

                const data = await response.json();
                const moderators = (data.MODERATORS || '').split(',').map(m => m.trim().toLowerCase()).filter(Boolean);

                if (moderators.includes(username)) {
                    showNotification('User is already a moderator', 'error');
                    return;
                }

                moderators.push(username);
                data.MODERATORS = moderators.join(',');

                // Save updated config
                const saveResponse = await fetch('/api/setup', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${adminToken}`
                    },
                    body: JSON.stringify(data)
                });

                if (saveResponse.ok) {
                    showNotification(`Added ${username} as moderator`, 'success');
                    input.value = '';
                    loadModerators();
                } else {
                    showNotification('Failed to save moderator', 'error');
                }
            } catch (error) {
                console.error('Error adding moderator:', error);
                showNotification('Error adding moderator', 'error');
            }
        }

        async function removeModerator(username) {
            if (!confirm(`Remove ${username} as moderator?`)) {
                return;
            }

            try {
                // Get current config
                const response = await fetch('/api/setup', {
                    headers: { 'Authorization': `Bearer ${adminToken}` }
                });

                if (!response.ok) {
                    showNotification('Failed to load current config', 'error');
                    return;
                }

                const data = await response.json();
                const moderators = (data.MODERATORS || '').split(',').map(m => m.trim().toLowerCase()).filter(Boolean);
                const index = moderators.indexOf(username.toLowerCase());

                if (index === -1) {
                    showNotification('User is not a moderator', 'error');
                    return;
                }

                moderators.splice(index, 1);
                data.MODERATORS = moderators.join(',');

                // Save updated config
                const saveResponse = await fetch('/api/setup', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${adminToken}`
                    },
                    body: JSON.stringify(data)
                });

                if (saveResponse.ok) {
                    showNotification(`Removed ${username} as moderator`, 'success');
                    loadModerators();
                } else {
                    showNotification('Failed to remove moderator', 'error');
                }
            } catch (error) {
                console.error('Error removing moderator:', error);
                showNotification('Error removing moderator', 'error');
            }
        }

        // Player Management Functions
        async function adminSearchPlayers() {
            const searchTerm = document.getElementById('admin-player-search').value.trim();
            if (!searchTerm) {
                showNotification('Please enter a search term', 'error');
                return;
            }

            try {
                const response = await fetch(`/api/debug/players/search?q=${encodeURIComponent(searchTerm)}&limit=20`, {
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include'
                });
                const result = await response.json();
                adminDisplayPlayerResults(result.data || []);
                showNotification(`Found ${(result.data || []).length} players`, 'success');
            } catch (error) {
                showNotification('Failed to search players', 'error');
            }
        }

        async function adminLoadAllPlayers(page = 1) {
            adminCurrentPlayersPage = page;
            try {
                const response = await fetch(`/api/debug/players?page=${page}&limit=25`, {
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include'
                });
                const result = await response.json();
                adminDisplayPlayerResults(result.data || []);
                adminDisplayPagination(result.pagination);
                showNotification(`Loaded ${(result.data || []).length} players`, 'success');
            } catch (error) {
                showNotification('Failed to load players', 'error');
            }
        }

        function adminDisplayPlayerResults(players) {
            const container = document.getElementById('admin-players-container');

            if (!players || players.length === 0) {
                container.innerHTML = '<p style="color: var(--text-secondary); text-align: center; padding: 20px;">No players found</p>';
                return;
            }

            // Helper to escape player names for use in onclick attributes
            const escapeForAttr = (str) => str.replace(/'/g, "\\'").replace(/"/g, '&quot;');
            const escapeHtml = (str) => str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

            container.innerHTML = `
                <table style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr style="border-bottom: 2px solid var(--input-border);">
                            <th style="text-align: left; padding: 10px;">Rank</th>
                            <th style="text-align: left; padding: 10px;">Name</th>
                            <th style="text-align: center; padding: 10px;">Points</th>
                            <th style="text-align: center; padding: 10px;">Level</th>
                            <th style="text-align: center; padding: 10px;">Wins/Fails</th>
                            <th style="text-align: center; padding: 10px;">Winrate</th>
                            <th style="text-align: center; padding: 10px;">Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${players.map(player => `
                            <tr style="border-bottom: 1px solid var(--input-border);">
                                <td style="padding: 10px;">#${player.rank || '-'}</td>
                                <td style="padding: 10px; font-weight: 500;">${escapeHtml(player.name)}</td>
                                <td style="text-align: center; padding: 10px;">${player.points || 0}</td>
                                <td style="text-align: center; padding: 10px;">${player.level || 1}</td>
                                <td style="text-align: center; padding: 10px;">${player.wins || 0}/${player.fails || 0}</td>
                                <td style="text-align: center; padding: 10px;">${(player.winrate || 0).toFixed(1)}%</td>
                                <td style="text-align: center; padding: 10px;">
                                    <button class="btn btn-small" style="background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);" onclick="adminOpenEditPlayerModal('${escapeForAttr(player.name)}')">Edit</button>
                                    <button class="btn btn-small btn-danger" onclick="adminDeletePlayer('${escapeForAttr(player.name)}')">Delete</button>
                                </td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;
        }

        function adminDisplayPagination(pagination) {
            const container = document.getElementById('admin-players-pagination');
            if (!pagination || pagination.totalPages <= 1) {
                container.innerHTML = '';
                return;
            }

            let html = '';
            if (pagination.hasPrev) {
                html += `<button class="btn btn-small btn-secondary" onclick="adminLoadAllPlayers(${pagination.page - 1})">Previous</button>`;
            }
            html += `<span style="padding: 8px 16px; color: var(--text-secondary);">Page ${pagination.page} of ${pagination.totalPages}</span>`;
            if (pagination.hasNext) {
                html += `<button class="btn btn-small btn-secondary" onclick="adminLoadAllPlayers(${pagination.page + 1})">Next</button>`;
            }
            container.innerHTML = html;
        }

        async function adminOpenEditPlayerModal(playerName) {
            try {
                const response = await fetch(`/api/debug/players/${encodeURIComponent(playerName)}`, {
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include'
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    console.error('Failed to load player:', response.status, errorData);
                    showNotification(errorData.message || `Failed to load player (${response.status})`, 'error');
                    return;
                }

                const result = await response.json();
                const player = result.data;

                if (!player || !player.hasPlayed) {
                    showNotification('Player not found or has no stats', 'error');
                    return;
                }

                adminCurrentEditPlayer = player.name;
                document.getElementById('adminEditPlayerName').textContent = player.name;
                document.getElementById('adminEditPoints').value = player.points || 0;
                document.getElementById('adminEditLevel').value = player.level || 1;
                document.getElementById('adminEditXp').value = player.xp || 0;
                document.getElementById('adminEditWins').value = player.wins || 0;
                document.getElementById('adminEditFails').value = player.fails || 0;
                document.getElementById('adminEditDuelWins').value = player.duelWins || 0;
                document.getElementById('adminEditDuelLosses').value = player.duelLosses || 0;
                document.getElementById('adminEditConeflipWins').value = player.coneflipWins || 0;
                document.getElementById('adminEditConeflipLosses').value = player.coneflipLosses || 0;
                document.getElementById('adminEditCurrentStreak').value = player.currentStreak || 0;
                document.getElementById('adminEditHighestStreak').value = player.highestStreak || 0;

                document.getElementById('adminEditPlayerModal').style.display = 'flex';
            } catch (error) {
                console.error('Error loading player:', error);
                showNotification('Failed to load player data', 'error');
            }
        }

        function closeAdminEditPlayerModal() {
            document.getElementById('adminEditPlayerModal').style.display = 'none';
            adminCurrentEditPlayer = null;
        }

        async function adminSavePlayerStats() {
            if (!adminCurrentEditPlayer) return;

            const stats = {
                points: parseInt(document.getElementById('adminEditPoints').value) || 0,
                level: parseInt(document.getElementById('adminEditLevel').value) || 1,
                xp: parseInt(document.getElementById('adminEditXp').value) || 0,
                wins: parseInt(document.getElementById('adminEditWins').value) || 0,
                fails: parseInt(document.getElementById('adminEditFails').value) || 0,
                duel_wins: parseInt(document.getElementById('adminEditDuelWins').value) || 0,
                duel_losses: parseInt(document.getElementById('adminEditDuelLosses').value) || 0,
                coneflip_wins: parseInt(document.getElementById('adminEditConeflipWins').value) || 0,
                coneflip_losses: parseInt(document.getElementById('adminEditConeflipLosses').value) || 0,
                current_streak: parseInt(document.getElementById('adminEditCurrentStreak').value) || 0,
                highest_streak: parseInt(document.getElementById('adminEditHighestStreak').value) || 0
            };

            try {
                const response = await fetch('/api/debug/players/edit', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({ name: adminCurrentEditPlayer, stats: stats })
                });
                const result = await response.json();

                if (result.status === 'success') {
                    showNotification(`Stats updated for ${adminCurrentEditPlayer}`, 'success');
                    closeAdminEditPlayerModal();
                    adminLoadAllPlayers(adminCurrentPlayersPage);
                } else {
                    showNotification(result.message || 'Failed to update stats', 'error');
                }
            } catch (error) {
                showNotification('Failed to save player stats', 'error');
            }
        }

        async function adminDeletePlayer(playerName) {
            if (!confirm(`Are you sure you want to delete player "${playerName}"? This action cannot be undone.`)) {
                return;
            }

            try {
                const response = await fetch('/api/debug/players/delete', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({ name: playerName })
                });
                const result = await response.json();

                if (result.status === 'success') {
                    showNotification(`Player ${playerName} deleted`, 'success');
                    adminLoadAllPlayers(adminCurrentPlayersPage);
                } else {
                    showNotification(result.message || 'Failed to delete player', 'error');
                }
            } catch (error) {
                showNotification('Failed to delete player', 'error');
            }
        }

        async function adminDeletePlayerFromModal() {
            if (!adminCurrentEditPlayer) return;
            await adminDeletePlayer(adminCurrentEditPlayer);
            closeAdminEditPlayerModal();
        }

        async function adminLoadPlayerForEdit() {
            const playerName = document.getElementById('admin-quick-player').value.trim();
            if (!playerName) {
                showNotification('Please enter a player name', 'error');
                return;
            }
            await adminOpenEditPlayerModal(playerName);
        }

        async function adminQuickDeletePlayer() {
            const playerName = document.getElementById('admin-quick-player').value.trim();
            if (!playerName) {
                showNotification('Please enter a player name', 'error');
                return;
            }
            await adminDeletePlayer(playerName);
        }
    </script>
</body>
</html> 

